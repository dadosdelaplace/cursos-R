---
title: "An√°lisis de datos en R"
subtitle: "Workbooks del curso de formaci√≥n en RTVE (2025)"
author: "Javier √Ålvarez Li√©bana"
format:
  html:
    theme: [default, style.scss]
    toc: true
    toc-title: √çndice
    toc-depth: 5
    toc-location: left
    number-sections: true
embed-resources: true
execute: 
  echo: true
---

```{r}
#| echo: false
setwd(dir = getwd())
```

## Clase 1

### üê£ Caso pr√°ctico I: airquality (manejo de vectores)

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaci√≥n solar, viento, temperatura, mes y d√≠a.

```{r}
library(datasets)
airquality
```

#### Pregunta 1

> ¬øC√≥mo averiguar qu√© [**representan los datos**]{.hl-yellow}? Piensa alg√∫n comando que nos d√© informaci√≥n sobre objetos en R, sabiendo que el nombre del dataset es `airquality`

```{r}
#| code-fold: true
#| eval: false
? airquality
```

Haciendo uso de `? ...` podemos consultar en el panel de ayuda lo que significa el objeto.

#### Pregunta 2


> Accede solo a los 5 primeros registros de temperaturas. Despu√©s accede al primero, segundo, quinto y d√©cimo

```{r}
#| code-fold: true
#| eval: false

# secuencia de 1 a 5
airquality$Temp[1:5] 

# otra forma
airquality$Temp[c(1, 2, 3, 4, 5)]

# primero, segundo, quinto y d√©cimo
airquality$Temp[c(1, 2, 5, 10)]
```



#### Pregunta 3

> Accede solo a los registros de temperaturas de mayo (tienes las temperaturas guardadas, piensa como acceder a ellos pero ahora usando una condici√≥n en lugar de √≠ndices concretos). Despu√©s accede a los elementos de mayo, abril y junio

```{r}
#| code-fold: true
#| eval: false

airquality$Temp[airquality$Month == 5]

# abril, mayo y junio
airquality$Temp[airquality$Month == 4 | airquality$Month == 5 |
                  airquality$Month == 6]

# otra forma m√°s legible: %in% nos comprueba si 
# los valores est√°n dentro de una lista permitida
airquality$Temp[airquality$Month %in% c(4, 5, 6)]
```

#### Pregunta 4

> ¬øCu√°ntos [**registros tenemos de mayo**]{.hl-yellow}? ¬øY de abril? 

```{r}
#| code-fold: true
#| eval: false

# Una forma para registros de mayo
sum(airquality$Month == 5)

# Otra forma: la longitud de un vector
length(airquality$Temp[airquality$Month == 5])

# √≠dem en abril
sum(airquality$Month == 4)
```

#### Pregunta 5

> Construye una nueva variable `date` con la fecha de cada registro (combinando a√±o, mes y d√≠a), sabiendo que todos los datos son de 1973. Pista: para construir una fecha antes debes tener un vector de textos (por ejemplo, "1973-01-01")

```{r}
#| code-fold: true
#| eval: false

# variable de tipo date
library(lubridate)
dates <- as_date(glue("{1973}-{airquality$Month}-{airquality$Day}"))
```

#### Pregunta 6

> Crea una nueva variable `temp_celsius` con la temperatura en ¬∫C (sabiendo que se calcula como $celsius = (fahr - 32) * (5/9)$). Tras ello calcula cu√°ntos d√≠as de junio superaron los 30 grados ¬∫C.

```{r}
#| code-fold: true
#| eval: false

# Temperatura en celsius
temp_celsius <- (airquality$Temp - 32) * (5/9)
temp_celsius 

# una forma
sum(temp_celsius[airquality$Month == 6] > 30)

# otra forma
length(temp_celsius[airquality$Month == 6 & temp_celsius > 30])
```

#### Pregunta 7

> Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]

# otra opci√≥n
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

#### Pregunta 8

> ¬øCu√°l fue la media de temperatura del mes de agosto? 

```{r}
#| code-fold: true
#| eval: false

# media en agosto
mean(airquality$Temp[airquality$Month == 8], na.rm = TRUE)
mean(temp_celsius[airquality$Month == 8], na.rm = TRUE)
```



### üê£ Caso pr√°ctico II: covid (tidy data)

En el fichero `messy_covid_data.csv` tienes un archivo con la cantidad de casos reportados durante la pandemia covid pero en **formato messy**: el nombre de las columnas codifica el sexo (H hombre, M mujer, NC no consta) y el grupo etario (0-9, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70-79, ‚â•80 a√±os y NC no consta).


Las soluciones ser√°n asumiendo que no se conoce a√∫n las opciones de tidyverse para modificar y filtrar tablas.

```{r}
library(readr)
datos <- read_csv(file = "./datos/messy_covid_data.csv")
datos
```

#### Pregunta 1

> Razona por qu√© no es tidydata y convi√©rte a tidy data en cuatro columnas: `provincia_iso`, `fecha`, `grupo`, `casos`.


```{r}
#| code-fold: true

# pivot_longer(): le indicamos que columnas no queremos pivotar,
# la variable a donde ir√°n los nombres y c√≥mo se llamar√° la variable
# de casos
# le incluimos `values_drop_na = TRUE` para que elimine los ausentes
# si los hubiese
library(tidyr)
tidy_covid <-
  datos |> 
  pivot_longer(cols = -c("provincia_iso", "fecha"),
               names_to = "grupo", values_to = "casos",
               values_drop_na = TRUE)
```

#### Pregunta 2

> Elimina los registros sin casos.


```{r}
#| code-fold: true

# pivot_longer(): le indicamos que columnas no queremos pivotar,
# la variable a donde ir√°n los nombres y c√≥mo se llamar√° la variable
# de casos
# le incluimos `values_drop_na = TRUE` para que elimine los ausentes
# si los hubiese
tidy_covid <- tidy_covid[tidy_covid$casos > 0, ]
```

#### Pregunta 3

> Una de las columnas (`grupo`) la tenemos codificada a veces como `cosa-cosa_cosa`, otras como `80-Inf_cosa` (sin cota superior en edad), otras como `NC-NC_cosa` (`NC` codifica los "no consta"). Intenta separar dicha columna para generar tres columnas nuevas `edad_inf`, `edad_sup` y `sexo` de manera adecuada. Recuerda que `NC` es un ausente. Pista: trata antes la variable `grupo` y reemplaza reemplazar los `"Inf"` y `"NC"` por `"NA"`, para que luego al convertirlos pueda pasarlos a num√©ricos sin problema



```{r}
#| code-fold: true
# Vamos a reemplazar los `"Inf"` y `"NC"` por `"NA"`, para que luego al
# convertirlos puedas pasarlos a `NA` num√©ricos
library(stringr)
tidy_covid$grupo <- str_replace_all(tidy_covid$grupo, "Inf|NC", "NA")
tidy_covid2 <-
  tidy_covid |>
  separate(col = "grupo", into = c("edad_inf", "edad_sup", "sexo"), convert = TRUE)
```

#### Pregunta 4

> Incorpora una nueva variable `mes_year` a la tabla que codifique conjuntamente el mes y el a√±o (por ejemplo, cualquier d√≠a de enero de 2020 ser√° algo similar a "1-2020" y cualquier d√≠a de febrero del 2021 ser√° "2-2021").

```{r}
#| code-fold: true
library(glue)
library(lubridate)
tidy_covid2$mes_year <-
  glue("{month(tidy_covid2$fecha)}-{year(tidy_covid2$fecha)}")
```

#### Pregunta 5

> Haciendo uso de esa variable de grupo `mes_year` y del vector de provincias permitidas que aparece debajo (codificadas por su c√≥digo ISO) obt√©n un resumen que nos devuelva en un tibble, para cada provincia permitida y cada mes-a√±o, la media de casos (sin importar edad ni sexo)


Solo necesitamos **recorrer cada provincia permitida** y **cada valor `mes_year` distinto**, as√≠ que creamos ambos vectores. Tambi√©n creamos un dataset vac√≠o `resumen_mes_provincia` donde, en cada iteraci√≥n, pegaremos una fila con su resumen. Una vez creados esos objetos, el **bucle simplemente deber√° recorrer cada valor de provincia y de mes-a√±o**: para el mes-a√±o i y la provincia j, filtramos solo los casos para esos valores concretos (de todo el vector de casos nos quedamos con aquellos que cumplan dicha condici√≥n, eliminando tambi√©n provincias ausentes). Tras filtrar guardamos la media ese filtro de casos


```{r}
#| code-fold: true
# madrid, barcelona, sevilla
prov_permitidas <- c("M", "B", "SE")

filtro_covid <-
  tidy_covid2[!is.na(tidy_covid2$provincia_iso) &
                tidy_covid2$provincia_iso %in% prov_permitidas, ]
resumen_mes_provincia <-
  tibble("M" = mean(filtro_covid$casos[filtro_covid$provincia_iso == "M"],
                    na.rm = TRUE),
         "B" = mean(filtro_covid$casos[filtro_covid$provincia_iso == "B"],
                    na.rm = TRUE),
         "SE" = mean(filtro_covid$casos[filtro_covid$provincia_iso == "SE"],
                    na.rm = TRUE))

```


### üê£ Caso pr√°ctico III: starwars (dplyr)

Vamos a usar al dataset `starwars` del paquete `{dplyr}`

```{r}
library(dplyr)
starwars
```

#### Pregunta 1

> Selecciona del conjunto de `starwars` (en el paquete `{dplyr}`) solo los personajes que sean androides o cuyo valor en `species` sea desconocido

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

#### Pregunta 2

> Selecciona del conjunto de starwars solo los personajes cuyo peso est√© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

#### Pregunta 3

>  Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```


#### Pregunta 4

>  Selecciona solo los personajes que sean humanos y de ojos marrones, para despu√©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```


#### Pregunta 5

>  Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (m√°s pesados, m√°s probable), teniendo en cuenta que no podemos tener probabilidades ausentes.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```


#### Pregunta 6

>  De los personajes que son humanos y miden m√°s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 m√°s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```


#### Pregunta 7

>  Filtra el conjunto de personajes y qu√©date solo con aquellos que en la variable `height` no tengan un dato ausente. Con los datos obtenidos del filtro anterior, selecciona solo las variables name, height, as√≠ como todas aquellas variables que CONTENGAN la palabra color en su nombre.


```{r}
#| code-fold: true
#| eval: false

starwars_2 <-
  starwars |> 
  drop_na(height) |> 
  select(name, height, contains("color"))
```

#### Pregunta 8

>  Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false

starwars_2 |> 
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color)
```


#### Pregunta 9

>  Selecciona solo las variables nombre, altura y as√≠ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```



#### Pregunta 10

>  Del dataset original, selecciona solo las variables num√©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

#### Pregunta 11

>  Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```


#### Pregunta 12

>  Calcula cu√°ntos personajes hay de cada especie, ordenados de m√°s a menor frecuencia.

```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

#### Pregunta 13

>  Tras eliminar ausentes en las variables de peso y estatura, a√±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

#### Pregunta 14

> Obt√©n el personaje m√°s joven por cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

#### Pregunta 15

>  Obt√©n la edad del personaje m√°s joven y m√°s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

#### Pregunta 16

>  Determina la cantidad de personajes en cada d√©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```
:::

:::


### üê£ Caso pr√°ctico IV: aviones de NYC (join)

Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerol√≠neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorol√≥gicos horarios de las estaciones LGA, JFK y EWR.

#### Pregunta 1

> Del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelos, a√±adiendo la informaci√≥n de las aerol√≠neas a dicha tabla.

```{r}
#| code-fold: true
flights_airlines <-
  flights |> 
  left_join(airlines, by = "carrier")
```

#### Pregunta 2

> A la tabla obtenida del cruce del apartado anterior, cruza despu√©s con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos informaci√≥n de sus aviones (y viceversa). 


```{r}
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum")
```


#### Pregunta 3

>  Repite el ejercicio anterior pero conservando ambas variables `year` (en una es el a√±o del vuelo, en la otra es el a√±o de construcci√≥n del avi√≥n), y distingui√©ndolas entre s√≠



```{r}
#| code-fold: true
flights_airlines_planes <- 
  flights_airlines |> 
  inner_join(planes, by = "tailnum",
             suffix = c("_flight", "_build_aircraft"))
```

#### Pregunta 4

>  Al cruce obtenido del ejercicio anterior incluye la longitud y latitud de los aeropuertos en `airports`, distinguiendo entre la latitud/longitud del aeropuerto en destino y en origen.

```{r}
#| code-fold: true
flights_airlines_planes %>%
  left_join(airports %>% select(faa, lat, lon),
            by = c("origin" = "faa")) |> 
  rename(lat_origin = lat, lon_origin = lon) |> 
  left_join(airports %>% select(faa, lat, lon),
            by = c("dest" = "faa")) |> 
  rename(lat_dest = lat, lon_dest = lon)
```

#### Pregunta 5

>  Filtra de `airports` solo aquellos aeropuertos de los que salgan vuelos. Repite el proceso filtrado solo aquellos a los que lleguen vuelos

```{r}
#| eval: false
#| code-fold: true
airports |> 
  semi_join(flights, by = c("faa" = "origin"))
airports |> 
  semi_join(flights, by = c("faa" = "dest"))
```

#### Pregunta 6

> ¬øDe cu√°ntos vuelos no disponemos informaci√≥n del avi√≥n? Elimina antes los vuelos que no tengan identificar (diferente a NA) del avi√≥n


```{r}
#| eval: false
#| code-fold: true
flights |> 
  drop_na(tailnum) |>
  anti_join(planes, by = "tailnum") |>
  count(tailnum, sort = TRUE) # de mayor a menor ya de paso
```


## Clase 2

### üê£ Caso pr√°ctico I: renta de municipios

#### Pregunta 1

> En el archivo `municipios.csv` tenemos guardada la informaci√≥n de los municipios de Espa√±a a fecha de 2019. La variable `LAU_code` representa el c√≥digo como unidad administrativa local seg√∫n la estandarizaci√≥n de la UE ([ver m√°s](https://ec.europa.eu/eurostat/web/nuts/local-administrative-units)). La variable `codigo_ine` est√° construida uniendo el c√≥digo de la provincia y el de la comunidad aut√≥noma.


> Por otro lado el archivo `renta_mun.csv` contiene datos de la renta per capita  de cada unidad administrativa (municipios, distritos, provincias, comunidades auton√≥nomas, etc) para diferentes a√±os.

> Carga ambos de manera adecuada

```{r}
#| code-fold: true
library(readr)
mun_data <- read_csv(file = "./datos/municipios.csv")

renta_mun <- read_csv2(file = "./datos/renta_mun.csv")
```


#### Pregunta 2

> Investiga el paquete `{janitor}` y haz uso de la funci√≥n `clean_names()` para normalizar nombres de variables

```{r}
#| code-fold: true
mun_data <-
  mun_data |> 
  janitor::clean_names()
renta_mun <-
  renta_mun |> 
  janitor::clean_names()
```

#### Pregunta 3

> ¬øSon tidydata? En caso de que no convierte el que toque de manera adecuada  (sin ausentes y cada dato del tipo correcto)

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun |> 
  pivot_longer(cols = contains("x"), names_to = "year",
               values_to = "renta", names_prefix = "x",
               names_transform = list(year = as.numeric),
               values_drop_na = TRUE)
```

#### Pregunta 4

> Si te fijas en la tabla anterior, tenemos datos de diferentes unidades administrativas que no siempre son municipios. Sabiendo que todos los municipios tienen un c√≥digo de 5 caracteres (que representan todos ellos n√∫meros), filtra s√≥lo aquellos registros que correspondan a unidades municipales.

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun_tidy |>
  filter(str_detect(codigo_ine, pattern = "[0-9]{5}") & 
           str_length(codigo_ine) == 5)
```

#### Pregunta 5

> A continuaci√≥n separa adecuadamente la variable de unidad administrativa en dos columnas: una con el c√≥digo (que ya tiene, por lo que debe eliminar uno de los dos) y el nombre. Elimina los espacios sobrantes (echa un vistazo a las opciones del paquete {stringr}).

```{r}
#| code-fold: true
renta_mun_tidy <-
  renta_mun_tidy |>
  separate(col = "unidad", into = c("cod_rm", "name"), sep = 5) |> 
  select(-cod_rm) |> 
  mutate(name = str_trim(name)) 
```


#### Pregunta 6

> ¬øEn qu√© a√±o fue mayor la renta media? ¬øY m√°s baja? ¬øCu√°l fue la renta mediana de los municipios de Espa√±a en 2019?

```{r}
#| eval: false
#| code-fold: true
summary_renta <-
  renta_mun_tidy |> 
  summarise("mean_renta" = mean(renta, na.rm = TRUE),
            .by = year)
summary_renta |>
  slice_min(mean_renta, n = 1)


summary_renta |>
  slice_max(mean_renta, n = 1)

renta_mun_tidy |> 
  filter(year == 2019) |> 
  summarise("median_renta" = median(renta, na.rm = TRUE))
```

#### Pregunta 7

> Haz lo que consideres para obtener el NOMBRE de la provincia con la renta media m√°s alta en 2019 y la m√°s baja

```{r}
#| code-fold: true
summary_by_prov <-
  renta_mun_tidy |> 
  filter(year == 2019) |> 
  left_join(mun_data, by = "codigo_ine", suffix = c("", "_rm")) |> 
  select(-contains("rm")) |> 
  summarise("mean_by_prov" = mean(renta, na.rm = TRUE),
            .by = c("cpro", "ine_prov_name"))

summary_by_prov |> 
  slice_max(mean_by_prov, n = 1)


```


#### Pregunta 8

> Obten de cada ccaa el nombre del municipio con mayor renta en 2019.

```{r}
#| code-fold: true
renta_mun_tidy |> 
  filter(year == 2019) |> 
  left_join(mun_data, by = "codigo_ine", suffix = c("", "_rm")) |> 
  select(-contains("rm")) |> 
  slice_max(renta, by = "codauto")
```

### üê£ Caso pr√°ctico II: simulaci√≥n

#### Pregunta 1

> Define una variable llamada `precio` que empiece en 100. Dise√±a un bucle de 20 iteraciones donde, en cada iteraci√≥n, el precio se reduzca a la mitad de su valor. Piensa que tipo de estructura de bucle deber√≠as usar. El valor final de precio deber√≠a ser 0.00009536743 (aprox).

```{r}
#| code-fold: true
#| eval: false
# Usamos un for ya que sabemos el n√∫mero de iteraciones 
# de manera prefijada (y no depende de nada)

# definimos inicialmente precio en 100
precio <- 100 

# para el bucle usamos por ejemplo i como √≠ndice, que va de 1 a 20
for (i in 1:20) {
  
  # el c√≥digo f√≠jate que es el mismo y no depende de i
  precio <- precio/2
  
}
precio
```

#### Pregunta 2

> Dise√±a una estructura de bucle de manera que encuentres la iteraci√≥n en la que `precio` es menor que 0.001 por primera vez. Una vez encontrado guarda el n√∫mero de iteraci√≥n y para el bucle.

```{r}
#| code-fold: true
# dos formas de hacerlo: for y while

# con for
precio <- 100 

# ya sabemos que en 20 es menor que 0.001 as√≠ que podemos poner
# dicha cantidad como tope sabiendo que no llegar√°
for (i in 1:20) {
  
  # si todav√≠a no es menor, seguimos dividiendo
  if (precio >= 0.001) { precio <- precio/2 }
  else {
    
    # si ya es menor, guardamos la iteraci√≥n (piensa por qu√© i - 1)
    iter <- i - 1 
    
    # y paramos
    break
  }
}

# con while
precio <- 100 

iter <- 0 # debemos inicializar las iteraciones

# no sabemos cuantas iteraciones, solo que debe parar cuando
# precio est√© por debajo de dicha cantidad
while (precio >= 0.001) {
  
  precio <- precio/2
    
  # estructura cl√°sica de while: si se corre iteraci√≥n
  # actualizamos un valor (en este caso que cuente una iteraci√≥n)
  iter <- iter + 1
}
```


#### Pregunta 3

> En R la funci√≥n `sample(x = ..., size = ...)` va sernos muy √∫til: de una colecci√≥n de elementos `x`, selecciona un n√∫mero `size` al azar de ellos. Por ejemplo, si queremos simular 3 veces el lanzamiento de un dado tenemos 6 elementos posibles (`x = 1:6`) y lo seleccionamos 3 veces (`size = 3`)

```{r}
sample(x = 1:6, size = 3)
```

> Al ser aleatorio, cada vez que lo ejecutas saldr√° algo distinto

```{r}
sample(x = 1:6, size = 3)
```


> ¬øY si queremos tirar 10 veces? Al tener solo 6 elementos posibles y elegir 10, no puede, as√≠ que le tenemos que indicar que queremos un sample (muestreo) con reemplazamiento (como sucede en el dado, cada cara puede repetirse al volver a tirarlo)

```{r}
sample(x = 1:6, size = 10, replace = TRUE)

```

> Con lo anterior, imagina que est√°s en un concurso de televisi√≥n donde te dan a elegir 3 puertas: en una hay un premio millonario y en las otras 2 una galleta oreo. Dise√±a el estudio de simulaci√≥n con bucles for para aproximar la probabilidad de que te toque el premio (obviamente tiene que darte aprox 0.3333333). Realiza el experimento para 1000 intentos. ¬øQu√© observas?

```{r}
#| code-fold: true
#| eval: false
# Definimos las puertas posibles
puertas <- c(1, 2, 3)

# Definimos los intentos
intentos <- 1000

# Definimos las veces que hemos ganado (al inicio empieza en 0 claro)
exitos <- 0

# Simulaci√≥n de una eleccion de puerta y un premio
for (i in 1:intentos) {
  
  # premio: de 3 puertas, solo est√° en una
  premio <- sample(x = puertas, size = 1)
    
  # puerta que seleccionas como concursante: de 3 puertas, te quedas con una
  eleccion <- sample(x = puertas, size = 1)
    
  # si la puerta seleccionada coincide con la que tiene el premio
  # sumas un √©xito, sino te quedas como est√°s
  exitos<- dplyr::if_else(eleccion == premio, exitos + 1, exitos)
    
}
# Tras jugar, lo dividimos entre el n√∫mero de veces que has jugado
exitos <- exitos / intentos
exitos
```

#### Pregunta 4

> Realiza el experimento para 10, 50 intentos, 100 intentos, 500 intentos, 1000 intentos, 10 000 intentos y 25 000 intentos (pista: necesitas un bucle dentro de otro). ¬øQu√© observas?

```{r}
#| code-fold: true
#| eval: false
# Definimos las puertas posibles
puertas <- c(1, 2, 3)

# Definimos los intentos
intentos <- c(10, 50, 100, 500, 1000, 10000, 25000)

# Definimos las veces que hemos ganado (al inicio empieza en 0 claro)
exitos <- rep(0, length(intentos))

# Simulaci√≥n de una eleccion de puerta y un premio
for (j in 1:length(intentos)) {
  for (i in 1:intentos[j]) {
    
    # premio: de 3 puertas, solo est√° en una
    premio <- sample(x = puertas, size = 1)
      
    # puerta que seleccionas como concursante: de 3 puertas, te quedas con una
    eleccion <- sample(x = puertas, size = 1)
      
    # si la puerta seleccionada coincide con la que tiene el premio
    # sumas un √©xito, sino te quedas como est√°s
    exitos[j] <- dplyr::if_else(eleccion == premio, exitos[j] + 1, exitos[j])
      
  }
  # Tras jugar, lo dividimos entre el n√∫mero de veces que has jugado
  exitos[j] <- exitos[j] / intentos[j]
}
exitos
```

#### Pregunta 5

> ¬øY si en cada ronda el presentador (tras tu elegir una puerta) te abriese una de las puertas no premiadas y que no has elegido: cambiar√≠as de puerta o te mantendr√≠as? Simula ambos casos y descubre cu√°l es la estrategia correcta (este problema se conoce como problema de Monty Hall y aparece incluso en pel√≠culas como 21 Black Jack)

```{r}
#| code-fold: true
#| eval: false
# Definimos las puertas posibles
puertas <- c(1, 2, 3)

# Definimos los intentos
intentos <- c(10, 50, 100, 500, 1000, 10000, 25000)

# Definimos las veces que hemos ganado (al inicio empieza en 0 claro)
# ahora dos estrategias: mantener o cambiar
exitos_mantengo <- exitos_cambio <- rep(0, length(intentos))

# Simulaci√≥n de una eleccion de puerta y un premio
for (j in 1:length(intentos)) {
  for (i in 1:intentos[j]) {
    
    # premio: de 3 puertas, solo est√° en una
    premio <- sample(x = puertas, size = 1)
      
    # puerta que seleccionas inicialmente
    eleccion_inicial <- sample(x = puertas, size = 1)
    
    # puerta que te podr√≠a abrir el presentador
    puertas_posibles <- puertas[!(puertas %in% c(eleccion_inicial, premio))]
    
    # si solo te podr√≠a abrir una (porque tu elecci√≥n y el premio son distintas)
    # te abre esa directamente. si te puede abrir dos (porque tu elecci√≥n
    # y el premio son la misma) decide una de las dos aleatorias
    if (length(puertas_posibles) == 1) {
      puerta_abierta <- puertas_posibles
      
    } else {
      puerta_abierta <- sample(x = puertas_posibles, size = 1)
    }
    
      
    # si mantienes: solo comprobar que eleccion_inicial == premio
    exitos_mantengo[j] <- 
      dplyr::if_else(eleccion_inicial == premio, exitos_mantengo[j] + 1, exitos_mantengo[j])
    
    # si cambias: tu elegiste una, el presentador te abrio otra, solo 
    # puedes cambiar a la que no conoces
    eleccion_cambio <- puertas[!(puertas %in% c(eleccion_inicial, puerta_abierta))]
    exitos_cambio[j] <-
      dplyr::if_else(eleccion_cambio == premio, exitos_cambio[j] + 1, exitos_cambio[j])
      
  }
  # Tras jugar, lo dividimos entre el n√∫mero de veces que has jugado
  exitos_cambio[j] <- exitos_cambio[j] / intentos[j]
  exitos_mantengo[j] <- exitos_mantengo[j] / intentos[j]
}
exitos_cambio
exitos_mantengo
```

#### Pregunta 6

> Dise√±a una funci√≥n propia con 3 argumentos: `puertas`, `puerta_elegida` y `cambio`. La primera podr√° tomar los valores `c(1, 2, 3, ..., n)` (simulando un concurso de n puertas, n al menos 3); la segunda un solo n√∫mero de puerta elegida entre las posibles; la tercera `TRUE/FALSE`. La funci√≥n debe replicar una simulaci√≥n de la pregunta 5 y devolver `TRUE` (el concursante gan√≥ el premio) o `FALSE`. Comprueba dentro de la funci√≥n que los argumentos son correctos; en caso contrario devuelve un mensaje de error. Tras dise√±ar la funci√≥n apl√≠cala y revisa que funciona cuando toca y que devuelve error cuando toca.

```{r}
#| code-fold: true
#| eval: false
# defino la funci√≥n con unos argumentos por defecto (los que tomar√°
# si al llamarle no se le asigna nada)
concurso <- 
  function(puertas = 1:3, puerta_elegida = 1, cambio = TRUE) {
  
    # primer check: ¬øpuertas_posibles es un vector num√©rico de al menos 3 puertas?
    if (length(puertas) < 3 | !is.numeric(puertas)) {
      stop("puertas debe ser un vector num√©rico de al menos longitud 3")
    }
    
    # segundo check: si puerta elegida est√° dentro de las posibles
    if (!(puerta_elegida %in% puertas)) {
      stop("puerta_elegida debe ser una opci√≥n dentro de puertas")
    }
    
    # tercer check: si cambio es una variable l√≥gica sin ausentes
    if (is.na(cambio) | !is.logical(cambio)) {
      stop("cambio debe ser una variable binaria sin ausentes")
    }
    
    # premio: de 3 puertas, solo est√° en una
    premio <- sample(x = puertas, size = 1)
      
    # puerta que seleccionas inicialmente
    eleccion_inicial <- puerta_elegida
    
    # puerta que te podr√≠a abrir el presentador
    puertas_posibles <- puertas[!(puertas %in% c(eleccion_inicial, premio))]
    
    if (length(puertas_posibles) == 1) {
      puerta_abierta <- puertas_posibles
    } else {
      puerta_abierta <- sample(x = puertas_posibles, size = 1)
    }
    
    eleccion_cambio <- puertas[!(puertas %in% c(eleccion_inicial, puerta_abierta))]
    
    if (length(eleccion_cambio) > 1) {
      eleccion_cambio <- sample(x = eleccion_cambio, size = 1)
    }
    exito <- dplyr::if_else(cambio, eleccion_cambio == premio, eleccion_inicial == premio)
  
    return(exito)
  }

# ejemplos que deber√≠an funcionar
concurso()
concurso(cambio = FALSE)
concurso(puertas = 1:7)
concurso(puertas = 1:7, puerta_elegida = 4, cambio = FALSE)

# ejemplos que no
concurso(puertas = 1:2)
concurso(puertas = c("a", "b", "c"))
concurso(puertas = 1:5, puerta_elegida = 7)
concurso(puertas = 1:5, puerta_elegida = 3, cambio = "si")
```

## Clase 3

### üê£ Caso pr√°ctico I: brexit

![](https://media.tenor.com/dn2Mqp-ZPL4AAAAM/boris-boris-johnson.gif)

Veamos un estudio de caso real basado en los art√≠culos [¬´The Brexit Vote: A Divided Nation, a Divided Continent¬ª (S. B. Hobolt, 2016)](https://www.tandfonline.com/doi/full/10.1080/13501763.2016.1225785) y  [¬´Who Voted for Brexit? A Comprehensive District-Level Analysis¬ª (S. O. Becker et al., 2017)](https://academic.oup.com/economicpolicy/article/32/92/601/4459491). Los datos se extraer√°n del repositorio de Github de [Elena Llaudet](https://raw.githubusercontent.com/ellaudet/DSS/refs/heads/master/BES.csv)


#### Pregunta 1

> Carga del repositorio el `.csv`

```{r}
#| code-fold: true
library(readr)
brexit_data <- read_csv(file = "https://raw.githubusercontent.com/ellaudet/DSS/refs/heads/master/BES.csv")
```


#### Pregunta 2

> Escribe el c√≥digo que consideres para responder a las siguientes preguntas

* ¬øCu√°l es el tama√±o muestral de la encuesta?
* ¬øCu√°ntas variables se han recopilado?
* ¬øCu√°ntos ausentes tiene cada variable?

```{r}
#| code-fold: true
#| eval: false
# tama√±o muestral
brexit_data |> 
  nrow()

# variables
brexit_data |> 
  ncol()

# ausentes
brexit_data |> 
  summarise(across(everything(), function(x) { sum(is.na(x)) }))
```


#### Pregunta 3

> Si te fijas hay 2851 ausentes en `leave` (variable binaria). Comprueba que todos ellos se deben a registros en los que la variable `vote` (variable cualitativa) toma valores `don't known` o `won't vote`. Hazlo tanto en modo tidyverse (`count`) como en `R base`

```{r}
#| code-fold: true
#| eval: false
brexit_data |>
  count(leave, vote)

table(brexit_data$leave, brexit_data$vote)
```


#### Pregunta 4

> Debajo tienes el c√≥digo de como se construir√≠a una tabla de frecuencias bidimensional en `R base`

```{r}
table(brexit_data$vote, brexit_data$education)
```

> Dise√±a lo mismo pero haciendo uso de tidyverse (pista: necesitas pivotar)

```{r}
#| code-fold: true
#| eval: false
brexit_data |> 
  count(vote, education) |> 
  pivot_wider(names_from = "education", values_from = "n")
```

**Moraleja**: aunque casi siempre ser√° m√°s legible y eficiente (y coherente) el c√≥digo en tidyverse, a veces nos tocar√° echar mano de `R base`. Por eso es importante distinguir ambas formas de trabajar.

Te dejo por cierto debajo c√≥mo se calcular√≠an las frecuencias relativas (`margin = 1` normaliza por filas y `margin = 2` por columnas)


```{r}
freq_abs <- table(brexit_data$vote, brexit_data$education)
prop.table(freq_abs)
prop.table(freq_abs, margin = 1)
prop.table(freq_abs, margin = 2)
```


#### Pregunta 5

> Usando las tablas relativas anteriores responder a

* ¬øCu√°ntas personas de los que votaron `leave` tiene un alto nivel educativo?

* De la gente con un bajo nivel educativo, ¬øqu√© % voto `leave`?

* ¬øCu√°l fue el nivel educativo es el menos propenso a votar?




#### Pregunta 6

> ¬øQu√© porcentaje estim√≥ la encuesta que vot√≥ por permanecer en la Uni√≥n Europea (el resultado real despu√©s del refer√©ndum fue del 51.89%)?

```{r}
#| eval: false
#| code-fold: true
prop.table(table(brexit_data$vote))
# 46.45 % sobre el total de encuestas

prop.table(table(brexit_data$vote[brexit_data$vote != "won't vote"]))
# 47.27 si obviamos los que dec√≠an no ir a votar
```
 

#### Pregunta 7

> Calcula la media de edad para cada opci√≥n de la variable `vote`.

```{r}
#| eval: false
#| code-fold: true
brexit_data |> 
  summarise("avg_age" = mean(age), .by = vote)
```


### üê£ Caso pr√°ctico II: encuesta de satisfacci√≥n

Vamos a seguir poniendo en pr√°ctica lo aprendido el dataset `SatisfaccionPacientes.csv`

```{r}
library(readr)
datos <-
  read_csv(file = "./datos/SatisfaccionPacientes.csv") |> 
  janitor::clean_names() |>
  mutate(estado_civil = factor(estado_civil),
         genero = factor(genero))
datos
```

#### Pregunta 1

> Convierte de manera adecuada la variable `estado_salud` a cualitativa ORDINAL

```{r}
#| code-fold: true
datos <-
  datos |>
  mutate(estado_salud =
           factor(estado_salud, levels = c("Malo", "Regular", "Bueno", "Excelente"),
                  ordered = TRUE))
```

#### Pregunta 2

> Haz uso de `table()` para calcular la tabla de frecuencias de `genero` y `estado_civil`

```{r}
#| code-fold: true
#| eval: false
table(datos$genero)
table(datos$estado_civil)
```

####  Pregunta 3

>  Calcula la tabla de frecuencias de las ORDINALES y piensa si ahora puedes a√±adir algo m√°s a la tabla de frecuencias). Tras ello usa el c√≥digo m√°s sencillo para responder a: ¬øcu√°ntas personas tienen un estado de salud regular (o peor)?

```{r}
#| code-fold: true
#| eval: false
freq_estado_salud <-
  datos |> 
  count(estado_salud) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs),
         frecuencia_acum_abs = cumsum(frecuencia_abs),
         frecuencia_acum_rel = cumsum(frecuencia_rel))
# Se ve dentro de la tabla. Hay 44+15 = 59 personas con un estado de salud malo o regular. 
# Con c√≥digo
datos |>
  count(estado_salud <= "Regular")
```

####  Pregunta 4

>  Si te fijas una de las modalidades es totalmente anecd√≥tica (solo 1 Excelente). Ser√≠a conveniente recategorizar la categor√≠a Excelente: siempre que detecte Excelente, lo debe recategorizar a Bueno (criterio general: las categor√≠as deben contener al menos un 5% de los individuos de toda la muestra).

```{r}
#| code-fold: true
datos <- 
  datos |> 
  mutate(estado_salud  = if_else(estado_salud  == "Excelente", "Bueno", estado_salud),
         # ojo: hay que redefinir los niveles de la cualitativa
         # ya que ha dejado de ser factor (veremos un d√≠a el paquete forcats para esto)
         estado_salud =
           factor(estado_salud, levels = c("Malo", "Regular", "Bueno"),
                  ordered = TRUE))
```

####  Pregunta 5

>  Calcula la media, mediana, rango intercuart√≠lico y desviaci√≥n t√≠pica de grado de satisfacci√≥n desagregado por sexo.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_grado_satisfaccion = mean(grado_satisfaccion),
           sd_grado_satisfaccion = sd(grado_satisfaccion),
           mediana_grado_satisfaccion = median(grado_satisfaccion),
           IQR_grado_satisfaccion =
             quantile(grado_satisfaccion, probs = 0.75) -
             quantile(grado_satisfaccion, probs = 0.25),
           .by = genero)
```

####  Pregunta 6

> Exporta los resultados anteriores (`resumen`) en un archivo `resumen.csv`. En lugar de un `read_csv()` vamos a usar `write_csv(tabla, file = "ruta")`

```{r}
#| code-fold: true
# importado como csv
write_csv(resumen, file = "./resumen.csv")
```

#### Pregunta 7

> Crear un diagrama de barras para la variable g√©nero. ¬øC√≥mo podr√≠amos decirle que cada barra (es decir, para cada modalidad de g√©nero) sea de un color (de relleno)?


```{r}
#| code-fold: true
library(ggplot2)
ggplot(datos) +
  # dentro de aes() para que dependa de la tabla
  geom_bar(aes(x = genero, fill = genero))
```


#### Pregunta 8

> Crear desde cero un diagrama de barras, con ajustes personalizados para la variable estado de salud

```{r}
#| code-fold: true
# Estado de salud (ahora el orden importa)
ggplot(datos) +
  geom_bar(aes(x = estado_salud, fill = estado_salud), alpha = 0.75) +
  ggthemes::scale_fill_colorblind() +
  labs(title = "Diagrama de barras de la variable estado salud", 
       x = "Categor√≠a",  y = "Frecuencia absoluta",
       fill = "Categor√≠a") +
  theme_minimal() 
```


F√≠jate que si **no tuvi√©semos la variable como cuali ordinal, las barras van por orden alfab√©tico**, no por jerarqu√≠a real

```{r}
ggplot(datos) +
  geom_bar(aes(x = as.character(estado_salud), fill = as.character(estado_salud)),
           alpha = 0.75) +
  ggthemes::scale_fill_colorblind() +
  labs(title = "Diagrama de barras de la variable estado salud", 
       x = "Categor√≠a",  y = "Frecuencia absoluta",
       fill = "Categor√≠a") +
  theme_minimal() 
```

#### Pregunta 9

> Crea el histograma inferior para las variable edad y tiempo de espera.

```{r}
#| code-fold: true
ggplot(datos) +
  geom_histogram(aes(x = edad), bins = 30, fill = "darkorange", alpha = 0.75) + 
  labs(title = "Histograma de edad", subtitle = "Bins = 30",
       x = "Valores", y = "Frecuencia absoluta") +
  theme_minimal()

ggplot(datos) +
  # Define el ancho de las barras y colores
  geom_histogram(aes(x = tiempo_espera), bins = 30, fill = "orchid", alpha = 0.75) + 
  labs(title = "Histograma de tiempo de espera", subtitle = "Bins = 30",
       x = "Valores", y = "Frecuencia absoluta") +
  theme_minimal()
```

#### Pregunta 10

> Crea el gr√°fico de densidad inferior para las variable edad y tiempo de espera.

```{r}
#| code-fold: true
ggplot(datos) +
  geom_density(aes(x = edad), color = "darkorange", 
               fill = "darkorange", alpha = 0.75) + 
  labs(title = "Gr√°fico de densidad de edad",
       x = "Valores", y = "Frecuencia relativa") +
  theme_minimal()

ggplot(datos) +
  geom_density(aes(x = tiempo_espera), color = "orchid", 
               fill = "orchid", alpha = 0.75) + 
  labs(title = "Gr√°fico de densidad de tiempo de espera",
       x = "Valores", y = "Frecuencia relativa") +
  theme_minimal()
```



#### Pregunta 11

> Realiza un boxplot para edad y un boxplot para numero de visitas PERO por g√©nero (dos variables, piensa c√≥mo)

```{r}
#| code-fold: true
ggplot(datos) +
  geom_boxplot(aes(y = edad), fill = "lightblue", alpha = 0.75) +  
  labs(title = "Boxplot de edad",  y = "Edad") +
  theme_minimal()

ggplot(datos) +
  geom_boxplot(aes(x = genero, y = tiempo_espera, fill = genero),
               alpha = 0.75) +
  labs(title = "Boxplot de tiempo de espera por g√©nero", 
       x = "G√©nero", y = "Tiempo de Espera") +
  theme_minimal()
```


> Haciendo uso del gr√°fico anterior:

a)  ¬øLa variable edad tiene outliers? ¬øQu√© edad tienen esos pacientes?

b)  ¬øQui√©n ha esperado m√°s los hombres o las mujeres?


### üê£ Caso pr√°ctico III: bronquitis y tabaco


Vamos a cargar el archivo de datos `fumadores.csv` donde tenemos datos de 96 pacientes sobre s√≠ o fuman y quienes han desarrollado o no bronquitis.

```{r}
datos <- read_csv(file = "./datos/fumadores.csv")
datos
```


#### Pregunta 1

> Realiza la tabla de contigencia de manera absoluta y relativa y responde a las siguientes preguntas

a) ¬øCu√°ntas personas fumaoras tienen bronquitis?

b) ¬øQu√© % de los fumadores est√° sano?

c) ¬øQu√© % del total son a la vez no fumadores y enfermos de bronquitis?

d) ¬øQu√© % de los enfermos son fumadores?

```{r}
#| code-fold: true
#| eval: false
table(datos$fumador, datos$estado)
prop.table(table(datos$fumador, datos$estado))
prop.table(table(datos$fumador, datos$estado), margin = 1)
prop.table(table(datos$fumador, datos$estado), margin = 2)
# a) 32 personas
# b) 38.46%
# c) 16%
# d) 61.53%
```

#### Pregunta 2

> Visualiza ambas variables (`fumador` y `estado`) a la vez de manera adecuada que nos permita comparar

```{r}
#| code-fold: true
#| eval: false

ggplot(datos) +
  geom_bar(aes(x = fumador, fill = estado), alpha = 0.6, position = "fill") +
  labs(x = "fumador", y = "Frec relativa", fill = "Estado") +
  theme_minimal()
```

#### Pregunta 3

> ¬øExisten evidencias en la muestra de una asociaci√≥n entre ambas variables?

```{r}
#| code-fold: true
#| eval: false
datos |> 
  summarise("sig_chisq" = chisq.test(datos$fumador, datos$estado)$p.value,
            "sig_fisher" = fisher.test(datos$fumador, datos$estado)$p.value)
# p-valor < alpha --> hay evidencias para rechazar la hip nula
# hay evidencias (no muy fuertes, quiz√°s aumentar tama√±o muestral?) de
# que las variables son dependientes y existe una asociaci√≥n
```


#### Pregunta 4

> Si hubiera asociaci√≥n, cuantifica la fuerza de dicha asociaci√≥n (y el sentido) y calcula el riesgo relativo de los fumadores a contraer bronquitis (respecto a no fumadores)

```{r}
#| code-fold: true
#| eval: false
fisher.test(datos$fumador, datos$estado)
# OR estimado = 0.3611 ==> piensa que tenemos no fumar primero y luego fumar ==>
# 1/0.3611 = 2.769316 > 1 ==> hay una asociaci√≥n positiva entre fumar y tener 
# bronquitis 
# La bronquitis en pacientes que fuman es 2.77 veces m√°s frecuente
# que en los pacientes que no fuman

# RR ratio
a <- 32  # Expuestos con evento
b <- 16  # Expuestos sin evento
c <- 20  # No expuestos con evento
d <- 28  # No expuestos sin evento

RR <- (a / (a + b)) / (c / (c + d))
# El grupo que fuma tiene un riesgo 1.6 veces mayor de que desarrollar bronquitis en comparaci√≥n con el grupo que no fuma.
```



### üê£ Caso pr√°ctico IV: salud mental

Esta la base de datos `datos_salud_mental.csv` tenemos informaci√≥n recopilada de 100 pacientes que acuden a un centro de salud mental. Se quiere realizar un estudio para ver el **impacto que tienen distintas caracter√≠sticas sobre la ansiedad y depresi√≥n** en estos 100 pacientes. Los datos incluyen una variedad de variables relacionadas con la salud mental, as√≠ como caracter√≠sticas demogr√°ficas y de estilo de vida.

```{r}
datos <-
  read_csv(file = "./datos/datos_salud_mental.csv") |> 
  janitor::clean_names()
datos
```


Las variables son:

* `id`: identificador √∫nico del paciente.
* `edad`: edad del paciente en a√±os.
* `Genero`: g√©nero del paciente.
* `ansiedad`: nivel de ansiedad del paciente en una escala del 1 al 10.
* `depresi√≥n`: nivel de depresi√≥n del paciente en una escala del 1 al 10.
* `sesiones_terapia`: n√∫mero de sesiones de terapia asistidas en el √∫ltimo a√±o.
* `actividad_fisica`: n√∫mero de d√≠as a la semana que el paciente realiza actividad f√≠sica.
* `horas_sueno`: n√∫mero de horas promedio de sue√±o por noche.
* `uso_drogas_recreativas`: indicador de si el paciente ha usado drogas recreativas en el √∫ltimo a√±o.
* `tipo_drogas`: tipo de drogas que ha consumido el paciente.


#### Pregunta 1

> ¬øDe qu√© tipo es cada variable? Convierte las que consideres a cualis nominales y a cualis ordinales, y si hay alguna variable que deba ser l√≥gica

```{r}
#| code-fold: true
# id: en realidad esto tendr√≠a ser un factor (un texto) ya que no cuenta nada
# Cuantitativas: edad, horas_sueno
# Cualitativas nominales: genero, tipo_drogas
# Cuanitativas discretas: sesiones_terapia y actividad_fisica
# Cuantitativas discretas pero que deber√≠amos tratarlas como cualis ordinales
# ya que son escalas: ansiedad, depresi√≥n
# Binarias (cualis ordinales muy concretas): uso_drogas_recreativas
datos <-
  datos |> 
  mutate("id" = as.character(id),
         "genero" = factor(genero), "tipo_drogas" = factor(tipo_drogas),
         "ansiedad" = factor(ansiedad, levels = as.character(1:10), ordered = TRUE),
         "depresion" = factor(depresion, levels = as.character(1:10), ordered = TRUE),
         "uso_drogas_recreativas" = (uso_drogas_recreativas == "Si"))
```


#### Pregunta 2

> Calcula la tabla de frecuencias absolutas y relativas de g√©nero.

```{r}
#| code-fold: true
tabla_freq_abs <- table(datos$genero)
tabla_freq_rel <- prop.table(tabla_freq_abs)
```


#### Pregunta 3

> Calcula la media de las 4 variables cuantitativas que tenemos desagregado por g√©nero. Exporta dicho resumen en un `.csv`

```{r}
#| code-fold: true
resumen <- 
  datos |> 
  drop_na(where(is.numeric)) |> 
  summarise(across(where(is.numeric), mean), .by = genero)
write_csv(resumen, file = "./datos/resumen.csv")
```

#### Pregunta 4

> Calcula la tabla de contigencia de las variables ansiedad vs genero. Calcula otra para ansiedad vs depresion. Usa `useNA = "always"` como argumento para incluir los `NA`

```{r}
#| code-fold: true
tabla_freq_genero_ansiedad <- table(datos$genero, datos$ansiedad, useNA = "always")
tabla_freq_depresion_ansiedad <- table(datos$depresion, datos$ansiedad, useNA = "always")
```


#### Pregunta 5

> Realiza un gr√°fico adecuado para la variable `edad`. Piensa como adaptarlo para tenerlo desagregado por `genero`.

```{r}
#| code-fold: true
#| eval: false
# Densidades
ggplot(datos) +
  geom_density(aes(x = edad), fill = "#459191", alpha = 0.4) +
  labs(x = "Edad (a√±os)", y = "Densidad (frec relativa)") +
  theme_minimal()

library(ggridges)
ggplot(datos) +
  geom_density_ridges(aes(x = edad, y = genero, fill = genero), alpha = 0.4) +
  ggthemes::scale_fill_colorblind() +
  labs(x = "Edad (a√±os)", y = "Sexo", fill = "G√©nero") +
  theme_minimal()

# Histograma (mala idea con pocos datos)
ggplot(datos) +
  geom_histogram(aes(x = edad), bins = 15, fill = "#459191", alpha = 0.4) +
  labs(x = "Edad (a√±os)", y = "Frec absoluta") +
  theme_minimal()
ggplot(datos) +
    geom_histogram(aes(x = edad, fill = genero), bins = 15, alpha = 0.25) +
    labs(x = "Edad (a√±os)", y = "Frec absoluta") +
    theme_minimal()

# Boxplot
ggplot(datos) +
  geom_boxplot(aes(y = edad), fill = "#459191", alpha = 0.4,
               outlier.size = 3, outlier.alpha = 0.9,
               outlier.color = "#991293", outlier.shape = 18) +
  labs(y = "Edad") +
  theme_minimal()

ggplot(datos, aes(x = genero, y = edad, fill = genero, color = genero)) +
  geom_boxplot(alpha = 0.4, outlier.size = 3, outlier.alpha = 0.9,
               outlier.color = "#991293", outlier.shape = 18) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  guides(color = "none") +
  labs(x = "G√©nero", y = "Edad", fill = "G√©nero") +
  theme_minimal()
```

#### Pregunta 6

> Realiza un gr√°fico adecuado para visualizar a la vez depresi√≥n y ansiedad.

```{r}
#| code-fold: true
#| eval: false

# f√≠jate que aunque sean n√∫meros, dado que son variables discretas
# de una escala, no permite una correcta visualizaci√≥n un diagrama
# de dispersi√≥n ya que hay muchos puntos iguales que se solapan
ggplot(datos) + 
  geom_point(aes(x = depresion, y = ansiedad)) +
  theme_minimal()

# una opci√≥n: se ve un patr√≥n (tipo "recta ascedente")
ggplot(datos |> count(depresion, ansiedad)) + 
  geom_point(aes(x = depresion, y = ansiedad, color = n, size = n)) +
  scale_color_viridis_c() +
  guides(size = "none") +
  theme_minimal()
```


#### Pregunta 7

>  ¬øExiste asociaci√≥n entre genero y uso de drogas? ¬øY entre depresi√≥n y ansiedad? Cuantifica la respuesta todo lo que puedas.

```{r}
#| code-fold: true
resumen_p_valores_1 <-
  datos |> 
  summarise("sig_chisq" = chisq.test(datos$genero, datos$uso_drogas_recreativas)$p.value,
            "sig_fisher" = fisher.test(datos$genero, datos$uso_drogas_recreativas)$p.value)
# p-valores >> alpha --> no evidencias para rechazar la independencia -->
# no hay evidencias para afirmar la dependencia

# con tantas categor√≠as Fisher no funciona
chisq.test(datos$depresion, datos$ansiedad)
# p-valores << alpha --> s√≠ hay evidencias para rechazar la independencia -->
# s√≠ hay evidencias para afirmar la dependencia
```

