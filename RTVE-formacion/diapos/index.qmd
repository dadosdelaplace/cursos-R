---
title: "Curso de formaci√≥n"
subtitle: "An√°lisis de datos en R para RTVE"
title-slide-attributes:
  data-background-image: img/rtve.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Curso impartido en RTVE ‚Ä¢ Javier √Ålvarez Li√©bana"
affiliation: Facultad de Estudios Estad√≠sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Curso de R impartido en RTVE"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[¬°Bienvenidos de nuevo a R!]{.flow}
:::

[**¬øMe hab√©is echado de menos? :)**]{style="color:#444442;"}

---

## ¬°Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. 

::: columns
::: {.column width="25%"}
![](img/me.jpeg)
:::

::: {.column width="75%"}
::: incremental
-   [**Javier √Ålvarez Li√©bana**]{.hl-yellow}, de Carabanchel. Licenciado en Matem√°ticas (UCM). [**Doctor en estad√≠stica**]{.hl-yellow} (UGR)

-   Encargado de la [**visualizaci√≥n y an√°lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Espa√±ola de Estad√≠stica e IO**]{.hl-yellow} y la [**Real Sociedad Matem√°tica Espa√±ola**]{.hl-yellow}.

- Formador de `R` ISCIII (actualmente) y el Ayuntamiento de Madrid (2024).

:::
:::
:::

Actualmente, [**investigador y docente en la Facultad de Estad√≠stica de la UCM**]{.hl-yellow}, e investigador colaborador del [**Network Science Institute**]{.hl-yellow} de la Northeastern University (Boston). Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaci√≥n**]{.hl-yellow} ‚Üí a programar se aprende programando

-   Entender los [**conceptos b√°sicos de R**]{.hl-yellow} desde cero ‚Üí aprender a abstraer ideas y algoritmos

-   Utilidad de programar ‚Üí flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Profundizar en el [**an√°lisis y preprocesamiento**]{.hl-yellow} de datos ‚Üí `{tidyverse}`

-   Adquirir habilidades en el [**an√°lisis estad√≠sticos de los datos**]{.hl-yellow}

:::
:::
:::

---

## Planificaci√≥n  {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | EJ. | WORKBOOK | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S1 | 8 ene | Repaso: re-toma de contacto | [üíª](#tu-turno-1-1) [üíª](#tu-turno-1-2) [üíª](#tu-turno-1-3) | [üê£](#caso-practico-1-1) [üê£](#caso-practico-1-2) [üê£](#caso-practico-1-3) [üê£](#caso-practico-1-4)  |  | 
| [2](#clase-2) | S2 | 13 ene | ... | ... | [üê£](#caso-practico-2-1) |  | 
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en **<https://javieralvarezliebana.es/cursos-R/RTVE-formacion/diapos/#/title-slide>**. En el men√∫ de las diapositivas (abajo a la izquierda) tienes una [**opci√≥n para descargarlas en pdf**]{.hl-yellow} en `Tools`
  
&nbsp;

* [**Material**]{.hl-yellow}: [**cuadernos de trabajo**](https://javieralvarezliebana.quarto.pub/workbook-rtve) y materiales extras y **res√∫menes de paquetes**

* [üóÉ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en Github **<https://github.com/dadosdelaplace/cursos-R/tree/main/RTVE-formacion/diapos/datos>**

* [üìö **Recursos de apoyo**]{.hl-yellow}: en ingl√©s <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.


# Clase 1: [welcome to R again]{.flow} {#clase-1}

[**Refrescando R**]{style="color:#444442;"}

* [Reminders](#reminders)
* [Tidy data](#tidy-data)
* [Preprocesamiento: dplyr](#tidy-data)
* [Importar y exportar](#import-export)


---

## Reminder: ¬øpor qu√© programar? {#reminders}

-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Reminder: requisitos

Por si se te hab√≠a olvidado, para el curso los √∫nicos requisitos ser√°n:

1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: ser√° nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>


::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## Reminder: R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) ‚Üí `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gram√°tica, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---


## Reminder: asignaci√≥n, ¬øigual?, argumentos

No se si recuerdas que en `R` vamos a distinguir [**tres tipos de ¬´igual¬ª**]{.hl-yellow}:

* [**Asignaci√≥n**]{.hl-yellow}: usaremos `<-` para asignar el valor de la derecha a la variable cuyo nombre tenemos a la izquierda


```{r}
a <- c(1, 2)
```

* [**Comparaci√≥n l√≥gica**]{.hl-yellow}: usaremos `==` para preguntar si lo de la izquierda es igual a lo de la derecha (la respuesta ser√° un vector l√≥gico)


```{r}
a == 1
```


* [**Argumentos**]{.hl-yellow}: usaremos `=` para asignar argumentos dentro de una funci√≥n


```{r}
mean(x = a, na.rm = TRUE)
```


---


## Reminder: errores y warning

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```


---

## Reminder: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto ser√° una ¬´carpeta¬ª**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio ra√≠z autom√°ticamente ser√° la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---


## Reminder: tipos de datos

¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Reminder: tipos de datos

¬øExisten [**variables m√°s all√° de los n√∫meros**]{.hl-yellow}? Piensa por ejemplo en los datos que podr√≠as guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre ser√° una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta ¬´¬øest√°s matriculado en la Facultad?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.

```{r}
birth_day <- lubridate::as_date("1989-09-10")
```
:::

---

## Reminder: tipos de datos



Imagina que adem√°s de la edad de una persona queremos guardar su nombre: ahora la variable ser√° de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritm√©ticas**]{.hl-red} (s√≠ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar n√∫mero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor l√≥gico, binario) que `"TRUE"` (texto).
:::

---

## Reminder: tipos de datos

Otro tipo fundamental ser√°n las [**variables l√≥gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```

. . .

Dado que internamente est√°n guardados como variables binarias, podemos [**realizar operaciones aritm√©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Reminder: tipos de datos

Las variables l√≥gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y ser√° muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor l√≥gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Reminder: tipos de datos

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deber√≠a representar un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha. Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.


```{r}
#| eval: false
install.packages("lubridate")
```


---

## Reminder: vectores

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que ser√≠a una columna de una tabla).

. . .

La forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre par√©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .


La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

---

## Reminder: secuencias

El vector m√°s famoso ser√° el de tipo num√©rico, y en concreto, las conocidas como [**secuencias num√©ricas**]{.hl-yellow}. El comando `seq(inicio, fin)` nos permite crear una [**secuencia num√©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 21)
```

. . .

Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

. . .

Tambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...` o su longitud con `l = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
seq(1, 10, l = 7) # secuencia desde 1 a 50 de longitud 7
```


---


## Reminder: vectores

Con los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros ‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)

. . .

¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Reminder: vectores


Una operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Reminder: vectores

Las [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Reminder: vectores

Otra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qu√©", "tal", "est√°s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al √∫ltimo, sin preocuparnos de cu√°l es, podemos pasarle como √≠ndice la propia longitud `x[length(x)]`
:::

---

## Reminder: vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "mar√≠a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## Reminder: vectores


Tambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Reminder: vectores


Por √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## Reminder: bases de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile.


* La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}. La opci√≥n m√°s habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Reminder: bases de datos

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos √≠ndices separados por comas**: √≠ndice de la fila y de la columna 

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

---

## Reminder: bases de datos

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
tabla
```

---

## Reminder: bases de datos

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambi√©n tiene las ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posici√≥n y ahora s√≠ tienen un significado), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

---

## Reminder: bases de datos

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}. En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
         "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---


## üíª Tu turno {#tu-turno-1-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Accede al tercer elemento de `x`. Accede al √∫ltimo elemento (sin importar la longitud, un c√≥digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Obt√©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y gu√°rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEM√ÅS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```



### [**Ejercicio 6**]{.hl-yellow}

üìù Dado el vector `x` del ejercicio anterior, ¬øcuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```



### [**Ejercicio 7**]{.hl-yellow}

üìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```


### [**Ejercicio 8**]{.hl-yellow}

üìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```



### [**Ejercicio 9**]{.hl-yellow}

üìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 10**]{.hl-yellow}

üìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 11**]{.hl-yellow}

üìù Cambia el c√≥digo inferior para filtrar solo los datos de la quinta observaci√≥n

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 12**]{.hl-yellow}

üìù Cambia el c√≥digo inferior para filtrar solo los datos del mes de agosto.


```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```


:::


---


## üê£ Caso pr√°ctico I: manejo de vectores {#caso-practico-1-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. 

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaci√≥n solar, viento, temperatura, mes y d√≠a.

```{r}
#| eval: false
library(datasets)
airquality
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-i-airquality-manejo-de-vectores)


---

## ¬øQu√© era tidyverse? {#tidy-data}

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programaci√≥n funcional, hace una d√©cada nac√≠a `{tidyverse}`, un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}

---

## ¬øQu√© era tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n

:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaci√≥n de datos



:::
:::



---

## ¬øQu√© era tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n


:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaci√≥n de datos

:::
:::


---

## Filosof√≠a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraci√≥n
-   hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.
-   c√≥digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna com√∫n**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tuber√≠a (pipe)

En `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::


. . .

::: callout-caution
## Apunte importante

Desde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).
:::

---

## Tuber√≠a (pipe)

La principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).


```{r}
library(tidyr)
table4a
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
‚ùé Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::



-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`


```{r}
table2
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
‚ùé Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

F√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el √∫ltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## Ejemplo: relig_income

Vamos a realizar un ejemplo juntos con la tabla `relig_income` del paquete `{tidyr}`. Como se indica en la ayuda `? relig_income`, la tabla representa la cantidad de personas que hay en cada tramo de ingresos anuales (20k = 20 000$) y en cada religi√≥n.

```{r}
relig_income
```

---

## Ejemplo: relig_income

```{r}
relig_income
```

[**¬øEs tidydata?**]{.hl-yellow} 

---

## Ejemplo: relig_income

```{r}
relig_income
```

No lo es ya que en realidad [**solo deber√≠amos tener una variable de ingresos**]{.hl-red} y la tenemos dividida en 11: todas ellas es la misma variable solo que adopta un valor diferente.  [**¬øC√≥mo convertirla a tidy data?**]{.hl-green}

---

## Ejemplo: relig_income


La idea es [**pivotar todas las columnas de ingresos**]{.hl-yellow} para que acaben en una sola columna llamada `income`, y los valores (el n√∫mero de personas) en otra llamada `people` (por ejemplo). La tabla la haremos m√°s larga y menos ancha as√≠ que...

. . .

```{r}
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people")
relig_tidy 
```

---

## Ejemplo: relig_income

Vamos a hilar m√°s fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el l√≠mite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`

```{r}
#| code-fold: true
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```

. . .

¬øEst√° ya ok? F√≠jate bien...

---

## Ejemplo: relig_income

Si te fijas la primera columna el `"$10k"` deber√≠a ser una cota superior, no inferior. ¬øC√≥mo indicarle que separe bien ese caso?

. . .

Le indicaremos que separe si encuentra `"-"` o `"<"` (usamos `|` para separar ambas opciones)

```{r}
#| code-fold: true
relig_tidy <-
  relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
```

---

## Ejemplo: relig_income


Piensa ahora como podemos [**convertir los l√≠mites de ingresos a num√©ricas (eliminando s√≠mbolos, letras, etc)**]{.hl-yellow}

. . .

Para ello usaremos el paquete `{stringr}`, en concreto la funci√≥n `str_remove_all()` a la que le podemos pasar los caracteres que queremos eliminar (f√≠jate que `$` al ser un caracter reservado en `R` hay que indic√°rselo con `\\$`)

```{r}
#| code-fold: true
library(stringr)
relig_tidy$income_inf <-
  str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <-
  str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy
```


---

## üíª Tu turno {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}


üìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```


### [**Ejercicio 2**]{.hl-yellow}

üìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la Organizaci√≥n Mundial de la Salud). ¬øEs tidy data? ¬øPor qu√©? Convierte a tidy data

```{r}
#| code-fold: true
who_tidy <-
  who2 |> 
  # con values_drop_na = TRUE eliminamos los NA
  pivot_longer(cols = -(country:year), names_to = "type",
               values_to = "cases", values_drop_na = TRUE)
who_tidy
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Si te fijas ahora en type tenemos codificada la informaci√≥n como diagnosis_sexo_edad. ¬øC√≥mo separarlo en 3 columnas? Investiga tanto `separate()` como las opciones de `pivot_longer()`

```{r}
#| code-fold: true
# con separate
who_tidy <-
  who_tidy |> 
  separate(col = "type", into = c("diagnosis", "sex", "age"))

# con pivot_longer
who_tidy <-
  who2 |> 
  pivot_longer(cols = -(country:year),
               names_to = c("diagnosis", "sex", "age"),
               values_to = "cases", values_drop_na = TRUE, names_sep = "_")
who_tidy
```


### [**Ejercicio 5**]{.hl-yellow}

üìù Por √∫ltimo, separa en dos (age_inf, age_sup) el tramo etario (que sean n√∫meros). Piensa c√≥mo hacerlo ya que no siempre son 4 n√∫meros

```{r}
#| code-fold: true
# Usamos separate y le indicamos las posiciones, pero desde atr√°s 
# ya que siempre el l√≠mite superior es un n√∫mero de 2 cifras
# y usamos convert = TRUE para convertir a n√∫meros
who_tidy <-
  who_tidy |> 
  separate(col = "age", into = c("age_inf", "age_sup"),
           sep = -2, convert = TRUE)
```

:::

---

## üê£ Caso pr√°ctico II: tidydata {#caso-practico-1-2}


En el fichero `messy_covid_data.csv` tienes un archivo con la cantidad de casos reportados durante la pandemia covid pero en **formato messy**: el nombre de las columnas codifica el sexo (H hombre, M mujer, NC no consta) y el grupo etario (0-9, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70-79, ‚â•80 a√±os y NC no consta). Las soluciones ser√°n asumiendo que no se conoce a√∫n las opciones de tidyverse para modificar y filtrar tablas.

&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-ii-covid-tidy-data)

---

## Preprocesamiento: dplyr {#dplyr}

Como vimos dentro de `{tidyverse}` tenemos el paquete `{dplyr}` para el [**preprocesamiento y depuraci√≥n**]{.hl-yellow} de los datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**c√≥digo sea legible**]{.hl-yellow}, como si fuese una **lista de instrucciones** que al leerla nos diga de manera muy evidente lo que est√° haciendo.

---

## Preprocesamiento: dplyr

Vamos a repasar con el dataset `accidentes2020_data` del paquete `{CDR}` que recopila los **datos de accidentes de tr√°fico** con v√≠ctimas y/o da√±os al patrimonio en la ciudad de Madrid registrados por la Polic√≠a Municipal durante 2020.

```{r}
accidentes_tb <- as_tibble(CDR::accidentes2020_data)
accidentes_tb
```

---

## Muestreo

:::: columns
::: {.column width="60%"}

Una de las operaciones m√°s comunes es lo que se conoce en estad√≠stica como [**muestreo**]{.hl-yellow}: una [**selecci√≥n o filtrado de registros**]{.hl-yellow} (una submuestra)

:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones l√≥gicas sobre los registros (`filter()`)

. . .

* [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posici√≥n (`slice()`)

. . .

* [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

* [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)


---

## Filtrar filas: filter()

El muestreo m√°s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condici√≥n l√≥gica: con `filter()` se seleccionar√°n solo individuos que cumplan ciertas condiciones

¬øCu√°les son los **accidentes que se produjeron en Carabanchel**?

. . .

```{r}
library(dplyr)
accidentes_tb |> 
  filter(distrito == "CARABANCHEL")
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes ocurridos el 31 de diciembre?

. . .

```{r}
library(lubridate)
accidentes_tb |> 
  filter(as_date(fecha, format = "%d/%m/%Y") == "2020/12/31")
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes ocurridos en diciembre en el que hay mujeres conductoras involucradas?

. . .

```{r}
accidentes_tb |> 
  filter(month(as_date(fecha, format = "%d/%m/%Y")) == 12 &
           tipo_persona == "Conductor" & sexo == "Mujer")
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes cuando hubo granizo, lluvia (intensa o d√©bil) o nieve?

. . .

```{r}
accidentes_tb |> 
  filter(estado_meteorol√≥gico %in%
           c("Granizando", "LLuvia intensa", "Lluvia d√©bil", "Nevando"))
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes cuya lesividad se sit√∫a entre 1 y 3 (ambos inclusive)?

. . .

```{r}
accidentes_tb |> 
  filter(between(as.numeric(lesividad), 1, 3))
```



---

## Filtrar filas: filter()

Las [**condiciones l√≥gicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .


::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores l√≥gicos**]{.hl-green}.
:::


---

## Eliminar ausentes

¬øCu√°les fueron los accidentes en los que el sexo de la persona involucrada es desconocido?

. . .

Los [**ausentes deber√≠an estar codificados como `NA`**]{.hl-yellow}, y usar `drop_na()` para depurarlos, pero no siempre van a estar ya codificados as√≠.

```{r}
accidentes_tb |> 
  filter(sexo == "Desconocido")
```


---

## Rebanadas de datos: slice()

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posici√≥n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de √≠ndices**]{.hl-yellow}


¬øCu√°les son los **7 primeros accidentes guardados** en la base de datos?

. . .

```{r}
accidentes_tb |> 
  slice(1:7)

# otra forma:
# accidentes_tb |> 
#   slice_head(n = 7)
```


---

## Rebanadas de datos: slice()

¬øCu√°les fueron los **primeros 100 accidentes** del a√±o (usando fecha y hora)?

. . .

```{r}
accidentes_tb |> 
  slice_min(dmy_hms(paste(fecha, hora)), n = 100)
```


---

## Rebanadas de datos: slice()

¬øCu√°les fue el **√∫ltimo accidente** del a√±o (usando fecha y hora)?

. . .

```{r}
accidentes_tb |> 
  slice_max(dmy_hms(paste(fecha, hora)), n = 1)
```


---

## Aleatorio: slice_sample()


El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` o `slice_sample(prop = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).


**Extrae el 10%** de la muestra de manera aleatoria

. . .

```{r}
accidentes_tb |> 
  slice_sample(prop = 0.1)
```


---

## Aleatorio: slice_sample()


::: callout-important
## Importante...

[**¬´Aleatorio¬ª no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas ¬´m√°s aleatorias¬ª que otras, simplemente tienen subyacente distintas leyes de probabilidad.

:::

**Extrae el 10% de la muestra de manera aleatoria pero** siendo m√°s probable de muestrear a los accidentes en los primeros d√≠as de mes

. . .

```{r}
accidentes_tb |> 
  slice_sample(prop = 0.1, weight_by = day(dmy(fecha)))
```


---


## Reordenar filas: arrange()


Tambi√©n podemos [**ordenar filas**]{.hl-yellow} en funci√≥n de alguna variable con `arrange()`

**Ordena** los accidentes por fecha

. . .

```{r}
accidentes_tb |> 
  arrange(dmy(fecha))
```


---

## Eliminar duplicados: distinct()

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.


**Elimina los duplicados** considerando duplicados aquellos registros con mismo `num_expediente`, mismo `tipo_accidente` y mismo `tipo_persona`

. . .

```{r}
accidentes_tb |>
  distinct(num_expediente, tipo_accidente, tipo_persona)
```

---


## Selecci√≥n columnas: select()

Hasta ahora todas las operaciones realizadas (aunque us√°semos info de columnas) eran por filas. En el caso de columnas, la acci√≥n m√°s sencilla es [**seleccionar variables por nombre**]{.hl-yellow} con `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

**Selecciona solo las columnas** `num_expediente`, `fecha`, `hora`, `distrito`, `tipo_persona`, `rango_edad` y `sexo`.

. . .

```{r}
accidentes_tb |> 
  select(num_expediente:hora, distrito, tipo_persona:sexo)
```


---

## Selecci√≥n columnas: select()

**Elimina la columna** `localizacion`.

. . .

```{r}
accidentes_tb |> 
  select(-localizacion)
```


---


## Selecci√≥n columnas: select()

Tambi√©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen/termina por un patr√≥n**]{.hl-purple}, que lo contengan o que cumplan una [**expresi√≥n regular**]{.hl-purple} (`matches()`).


**Selecciona las columnas** `num_expediente`, `fecha`, `hora` y aquellas que apelen a coordenas o a `tipo_`.

. . .

```{r}
accidentes_tb |> 
  select(num_expediente, fecha, hora, starts_with("coordenada"), 
         starts_with("tipo_"))
```



---

## Selecci√≥n columnas: select()


Tambi√©n podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funci√≥n que devuelva un valor l√≥gico de tipo de dato.

**Selecciona las columnas** de tipo character.

. . .

```{r}
accidentes_tb |> 
  select(where(is.character))
```


---

## Renombrar: rename()


A veces tambi√©n podemos querer [**modificar la ¬´metainformaci√≥n¬ª**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.


**Renombra las columnas** `num_expediente` como `numero_exp`

. . .

```{r}
accidentes_tb |> 
  rename(numero_exp = num_expediente)
```

---


## Modificar columnas: mutate()

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 

Haciendo uso de las funciones de `{lubridate}` **crea una nueva columna** llamada `fecha_hora` que guarde la fecha y hora en un formato fecha-hora (`datetime`) y elimina dichas variables originales

. . .

```{r}
accidentes_tb |> 
  mutate("fecha_hora" = dmy_hms(paste(fecha, hora)), .after = num_expediente) |> 
  select(-fecha, -hora)
```

---


## Modificar columnas: mutate()


**Modifica la columna** `numero` que ya existe para convertirla a tipo numeric.

```{r}
accidentes_tb <-
  accidentes_tb |> 
  mutate("numero" = as.numeric(numero))
accidentes_tb
```


---

## Modificar columnas: mutate()

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funci√≥n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolver√° una constante**]{.hl-red}
:::

```{r}
#| message: false
#| warning: false
accidentes_tb |> 
  mutate("dummy" = mean(numero, na.rm = TRUE),
         .before = everything())
```


---

## Recategorizar


**Recodifica** la variable sexo tal que si no se conoce su valor se incluye `NA`

. . .

```{r}
accidentes_tb |> 
  mutate("sexo" = if_else(sexo == "Desconocido", NA, sexo)) |> 
  select(num_expediente, sexo)
```

---

## Recategorizar


**Recodifica** la variable `estado_meteorol√≥gico` para dejar solo `"Despejado"`, `"Precipitaci√≥n"` (incluye lluvia, nieve, granizo), `"Nublado"` y `NA`

. . .

```{r}
accidentes_tb |> 
  mutate("estado_meteorol√≥gico" =
           case_when(estado_meteorol√≥gico == "Despejado" ~ "Despejado",
                     estado_meteorol√≥gico %in%
                       c("Granizando", "Lluvia intensa",
                         "Lluvia d√©bil", "Nevando") ~ "Precipitaci√≥n",
                     estado_meteorol√≥gico == "Nublado" ~ "Nublado",
                     TRUE ~ NA)) |> 
  select(num_expediente, estado_meteorol√≥gico)
```


---


## Contar: count()


Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estad√≠sticas. Empecemos por lo sencillo: [**¬øc√≥mo contar (frecuencias)?**]{.hl-yellow}


¬øCu√°ntos accidentes hay guardados de cada sexo? 

. . .


```{r}
accidentes_tb |> 
  count(sexo, sort = TRUE)
```

---

## Contar: count()


¬øQu√© % del total representa cada sexo?


. . .

```{r}
accidentes_tb |> 
  count(sexo, sort = TRUE) |> 
  mutate("prop" = n/sum(n))
```

. . .

```{r}
# modo R base
prop.table(table(accidentes_tb$sexo))
```



---

## Contar: count()

¬øCu√°ntos accidentes hubo para cada sexo y cada tipo de persona (conductor, peat√≥n, etc)?

. . .

```{r}
accidentes_tb |> 
  count(sexo, tipo_persona, sort = TRUE)
```

---

## Agrupar: group_by()


¬øCu√°l fueron los primeros accidente del a√±o por cada sexo?

. . .

```{r}
accidentes_tb |> 
  slice_min(dmy_hms(paste(fecha, hora)), n = 1, by = sexo,
            with_ties = FALSE)
```

---

## Agrupar: group_by()


Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} que modificar√° las acciones futuras.

¬øCu√°l fue el accidente m√°s lesivo por cada tipo de persona y sexo?

. . .

```{r}
accidentes_tb |> 
  slice_max(lesividad, n = 1, by = c(sexo, tipo_persona))
```


---


## Resumir: summarise()


Por √∫ltimo tenemos `summarise()`, que nos permitir√° sacar res√∫menes estad√≠sticos. 


**Calcula la media** de accidentes diarios por sexo

. . .


```{r}
accidentes_tb |> 
  count(sexo, fecha) |> 
  summarise("media_diaria" = mean(n), .by = sexo)
```

---

## Resumir: summarise()


::: callout-warning
## Cuidado

F√≠jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que est√© indicado.
:::


**Calcula la media de lesividad** de los accidentes por tipo de persona

. . .


```{r}
accidentes_tb |>
  mutate("lesividad" = as.numeric(lesividad)) |> 
  drop_na(lesividad) |> 
  summarise("media_lesividad" = mean(lesividad), .by = tipo_persona)
```


---

## Resumir: reframe()


En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos m√°s de un valor por variable**]{.hl-yellow}.


**Calcula los cuartiles de la variables lesividad** 

. . .


```{r}
accidentes_tb |> 
  mutate("lesividad" = as.numeric(lesividad)) |> 
  drop_na(lesividad) |> 
  reframe(quantile(lesividad))
```

---

## Tip: percent_rank()


La funci√≥n `percent_rank()` es bastante √∫til para, dada una variable, calcular en qu√© [**percentil se sit√∫a cada observaci√≥n**]{.hl-yellow} (de 0 a 1: si 0.468, ese registro para dicha variable ocupa el percentil 46.8%).

```{r}
accidentes_tb |> 
  mutate("lesividad" = as.numeric(lesividad)) |> 
  drop_na(lesividad) |> 
  mutate("lesividad_rank" = percent_rank(lesividad)) |> 
  select(num_expediente, lesividad, lesividad_rank)
```


---


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la informaci√≥n en una sola tabla**]{.hl-yellow} y a veces nos interesar√° cruzar la informaci√≥n de distintas fuentes.

. . .

Para ello usaremos un cl√°sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, que nos permitir√°n [**cruzar una o varias tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo `join` por la columna `DNI`).

---

## Relacionando datos

La estructura b√°sica es la siguiente:

```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

![](img/sql-joins.jpg)

. . .


Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join


* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2¬™ tabla).

En nuestra caso queremos incorporar a `tb_1` la informaci√≥n de `tb_2`, identificando los registros por la columna key (`by = "key"`, la columna por la que tiene que cruzar)

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

F√≠jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---



## Right join


* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la primera.


Vamos ahora a incorporar a `tb_2` la informaci√≥n de `tb_1`, identificando los registros por la columna key (`by = "key"`)

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::

---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

F√≠jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamar√°n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en qu√© columna de cada tabla est√°n las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---

## Claves y sufijos

Adem√°s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretar√° como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

Tambi√©n podr√≠a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

F√≠jate que [**por defecto nos a√±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especific√°rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---


## Full join


* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendr√° las observaciones de ambas**]{.hl-yellow} tablas, [**a√±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

* `inner_join()`: solo sobreviven los [**registros cuyo id est√© en ambas**]{.hl-yellow} tablas.

Frente a los outer join est√° lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

F√≠jate que en t√©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo √∫nico que cambia es el orden de las columnas que a√±ade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por √∫ltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave est√° tambi√©n en la segunda**]{.hl-yellow} (como un inner join pero sin a√±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no est√°n).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## üíª Tu turno {#tu-turno-1-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Vamos a realizar un [**an√°lisis de las canciones Taylor Swift**]{.hl-yellow} haciendo uso del paquete `{taylor}`


```{r}
library(taylor)
taylor_album_songs
```
¬øCu√°ntas canciones hay guardadas? ¬øCu√°ntas caracter√≠sticas de cada una?

```{r}
#| code-fold: true
#| eval: false
taylor_album_songs |> nrow()
taylor_album_songs |> ncol()
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Obt√©n los √°lbumes √∫nicos del dataset. ¬øCu√°ntos hay?

```{r}
#| code-fold: true
#| eval: false
taylor_album_songs |> distinct(album_name)
taylor_album_songs |>
  distinct(album_name) |>
  nrow()
```


### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øEn cu√°ntas canciones tuvo colaboraci√≥n con otro artista? 

```{r}
#| code-fold: true
#| eval: false

# n¬∫ canciones con colaboraci√≥n
taylor_album_songs |>
  drop_na(featuring) |>
  nrow()
```

### [**Ejercicio 4**]{.hl-yellow}

üìù ¬øCu√°ntos artistas (√∫nicos) han colaborado con ella?

```{r}
#| code-fold: true
#| eval: false
# n¬∫ de colaboradores √∫nicos
taylor_album_songs |>
  drop_na(featuring) |> 
  summarise(n_collabs = n_distinct(featuring))
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Crea un nuevo `tibble` solo con las variables `album_name`, `album_release`, `track_name`, `featuring` y `duration_ms`. Despu√©s ordena dicho tibble de m√°s reciente a m√°s antiguo

```{r}
#| code-fold: true
#| eval: false
nuevo_tb <-
  taylor_album_songs |>
  select(album_name, album_release, track_name, featuring, duration_ms)
nuevo_tb |> 
  arrange(desc(album_release))
```


### [**Ejercicio 6**]{.hl-yellow}

üìù A√±ade al dataset anterior 2 variables con el mes y a√±o de la variable de fecha `album_release`. Piensa c√≥mo determinar el mes con m√°s canciones

```{r}
#| code-fold: true
#| eval: false
library(lubridate)
nuevo_tb <-
  nuevo_tb |> 
  mutate(month = month(album_release), year = year(album_release)) 
nuevo_tb |> 
  count(month, sort = TRUE)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Obt√©n la duraci√≥n media de las canciones en minutos (variable `duration_ms` en milisegundos). Extrae la info de la canci√≥n que m√°s dura

```{r}
#| code-fold: true
#| eval: false

nuevo_tb |>
  drop_na(duration_ms) |> 
  summarise(avg_dur = mean(duration_ms/60000))

nuevo_tb |> 
  slice_max(duration_ms)
```

:::

--- 

## üê£ Caso pr√°ctico III: starwars {#caso-practico-1-3}

Vamos a usar al dataset `starwars` del paquete `{dplyr}`

```{r}
library(dplyr)
starwars
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-iii-starwars-dplyr)


---

## üê£ Caso pr√°ctico IV: aviones {#caso-practico-1-4}


Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerol√≠neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorol√≥gicos horarios de las estaciones LGA, JFK y EWR.

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-iv-aviones-de-nyc-join)


# Clase 2: [welcome to R again]{.flow} {#clase-2}

[**...**]{style="color:#444442;"}

* [Importar y exportar](#import-export)

---

## Importar/exportar {#import-export}

Hasta ahora s√≥lo hemos utilizado datos ya cargados en paquetes, pero muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy f√°cilmente en diferentes formatos:


* [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda`, `.RData` y `.rds`

* [**Rectangular data (datos tabulados)**]{.hl-yellow}: archivos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: archivos `.txt`.

* [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

* [**Datos desde Google Drive**]{.hl-yellow}

* [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

---

## Formatos nativos

Los ficheros [**m√°s sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros basta con [**utilizar la funci√≥n**]{.hl-yellow} `load()` proporcion√°ndole la ruta del fichero.

* Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`


```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```


---

## Formatos nativos

* Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
airquality |> as_tibble()
```

---

## Formatos nativos

Tenga en cuenta que los archivos cargados con `load()` se cargan [**autom√°ticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no s√≥lo se pueden cargar conjuntos de datos: `load()` nos permite cargar m√∫ltiples objetos (no s√≥lo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno.

```{r}
load(file = "./datos/multiple_objects.rda")
```


---

## Formatos nativos

* Archivos `.rds`: para este tipo debemos utilizar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de c√°ncer de pulm√≥n**]{.hl-purple} del North Central Cancer Treatment Group. Observe que ahora [**los archivos .rds incorporar solo una tabla, no un objeto en general**]{.hl-red}


```{r}
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |>
  as_tibble()
lung_cancer
```


::: callout-important

## Importante

Las [**rutas**]{.hl-yellow deben ser siempre [**sin espacios, √±, ni acentos**]{.hl-yellow}. 


:::

---

## Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones √∫tiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.


:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
* `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
* `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
* `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
* `read_delim()`: funci√≥n generar con opci√≥n de [**especificar el delimitador**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos ellos necesitan como **argumento la ruta del fichero** m√°s **otros opcionales** (saltar cabecera o no, decimales, etc). Ver m√°s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).


. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por qu√© no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de la variable**]{.hl-yellow} se har√° normalmente [**autom√°ticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.


```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque normalmente lo hace bien autom√°ticamente podemos [**especificar el formato expl√≠citamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importar√° como car√°cter). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```

---

## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indic√°ndolo en `col_select = ...` (en formato lista, con `col_select = ...`).


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

---

## Datos tabulados (.txt)

¬øQu√© ocurre cuando el [**separador no es correcto**]{.hl-red}?


. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe d√≥nde separar**]{.hl-yellow}


```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```


---

## Datos tabulados (.txt)

Para ello tenemos.

* `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un  [**espacio**]{.hl-yellow}.

* `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos Excel (.xls, .xlsx)

Otro paquete de importaci√≥n clave ser√° el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones ser√°n clave:

* `read_xls()` espec√≠fica para `.xls`, `read_xlsx()` espec√≠fica para `.xlsx`.
* `read_excel()`: tanto para `.xls` como para `.xlsx`.


. . .

Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

---

## Datos Excel (.xls, .xlsx)


```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy com√∫n**]{.hl-red} es que haya alg√∫n tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.


---

## Datos Excel (.xls, .xlsx)

Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el n√∫mero de filas a saltar).


```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```


---

## Datos Excel (.xls, .xlsx)

Adem√°s con `col_names = ...` ya podemos renombrar las columnas en la importaci√≥n ([**proporcionar nombres supone 1¬™ l√≠nea ya como dato**]{.hl-yellow})


```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

---

## Datos Excel (.xls, .xlsx)

A veces las  [**fechas de Excel tienen un formato incorrecto**]{.hl-red} (sorpresa): podemos utilizar `convertToDate()` del paquete `{openxlsx}` para convertirlo.



```{r}
library(openxlsx)
deaths$muerte <- convertToDate(deaths$muerte)
deaths
```
   

---

## Datos Excel (.xls, .xlsx)

Tambi√©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su n√∫mero) utilizaremos el argumento `sheet = ...`.


```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```

---

## Datos Excel (.xls, .xlsx)

 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

---

## Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitir√° [**importar ficheros de los 3 software de pago m√°s importantes**]{.hl-yellow}: SAS, SPSS y Stata.


```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---


## Exportar

De la misma forma que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportar en `.RData` (opci√≥n recomendada para variables almacenadas en `R`). Recuerda que esta extensi√≥n [**s√≥lo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```

---

## Exportar

La ventaja de `.RData` es que podemos [**exportar m√∫ltiples variables de nuestro environment**]{.hl-yellow}, no solo un √∫nico dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```

---

## Exportar

* [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el m√°s recomendable para exportar bases de datos de tama√±o peque√±o o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

---

## Importar desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

---

## Importar desde wikipedia

El paquete `{rvest}`, uno de los m√°s √∫tiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(¬´table¬ª)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.


```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

---


## üê£ Caso pr√°ctico I: renta municipios {#caso-practico-2-1}

En el archivo `municipios.csv` tenemos guardada la informaci√≥n de los municipios de Espa√±a a fecha de 2019. La variable `LAU_code` representa el c√≥digo como unidad administrativa local seg√∫n la estandarizaci√≥n de la UE ([ver m√°s](https://ec.europa.eu/eurostat/web/nuts/local-administrative-units)).La variable `codigo_ine` est√° construida uniendo el c√≥digo de la provincia y el de la comunidad aut√≥noma.


Por otro lado el archivo `renta_mun` contiene datos de la renta per capita  de cada unidad administrativa (municipios, distritos, provincias, comunidades auton√≥nomas, etc) para diferentes a√±os.



&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-i-renta-de-municipios)





