---
title: "Curso de formaci√≥n"
subtitle: "An√°lisis de datos en R para RTVE"
title-slide-attributes:
  data-background-image: img/rtve.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Curso impartido en RTVE ‚Ä¢ Javier √Ålvarez Li√©bana"
affiliation: Facultad de Estudios Estad√≠sticos (UCM)
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Curso de R impartido en RTVE"
    slide-number: c/t
execute:
  echo: true
---

::: r-fit-text
[¬°Bienvenidos de nuevo a R!]{.flow}
:::

[**¬øMe hab√©is echado de menos? :)**]{style="color:#444442;"}

---

## ¬°Buenas!

[**Correo**]{.hl-green}: **<javalv09@ucm.es>**. 

::: columns
::: {.column width="25%"}
![](img/me.jpeg)
:::

::: {.column width="75%"}
::: incremental
-   [**Javier √Ålvarez Li√©bana**]{.hl-yellow}, de Carabanchel. Licenciado en Matem√°ticas (UCM). [**Doctor en estad√≠stica**]{.hl-yellow} (UGR)

-   Encargado de la [**visualizaci√≥n y an√°lisis de datos covid**]{.hl-yellow} del Principado de Asturias (2021-2022).

-   Miembro de la [**Sociedad Espa√±ola de Estad√≠stica e IO**]{.hl-yellow} y la [**Real Sociedad Matem√°tica Espa√±ola**]{.hl-yellow}.

- Formador de `R` ISCIII (actualmente) y el Ayuntamiento de Madrid (2024).

:::
:::
:::

Actualmente, [**investigador y docente en la Facultad de Estad√≠stica de la UCM**]{.hl-yellow}, e investigador colaborador del [**Network Science Institute**]{.hl-yellow} de la Northeastern University (Boston). Divulgando por [**Twitter**](https://twitter.com/dadosdelaplace) e [**Instagram**](https://instagram.com/javieralvarezliebana)


---

## Objetivos

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
-   Quitarnos el [**miedo a los errores en programaci√≥n**]{.hl-yellow} ‚Üí a programar se aprende programando

-   Entender los [**conceptos b√°sicos de R**]{.hl-yellow} desde cero ‚Üí aprender a abstraer ideas y algoritmos

-   Utilidad de programar ‚Üí flujos de trabajo [**reproducibles**, **transparentes**]{.hl-yellow} y mantenibles

-   Profundizar en el [**an√°lisis y preprocesamiento**]{.hl-yellow} de datos ‚Üí `{tidyverse}`

-   Adquirir habilidades en el [**an√°lisis estad√≠sticos de los datos**]{.hl-yellow}

:::
:::
:::

---

## Planificaci√≥n  {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  CLASE | SEMANA | FECHAS | TOPIC | EJ. | WORKBOOK | ENTREGA | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1](#clase-1) | S1 | 8 ene | Repaso: re-toma de contacto | [üíª](#tu-turno-1-1) [üíª](#tu-turno-1-2) [üíª](#tu-turno-1-3) | [üê£](#caso-practico-1-1) [üê£](#caso-practico-1-2) [üê£](#caso-practico-1-3) [üê£](#caso-practico-1-4)  |  | 
| [2](#clase-2) | S2 | 13 ene | ... | ... | [üê£](#caso-practico-2-1) |  | 
:::
:::

---

## Materiales

* [**Diapositivas**]{.hl-yellow}: diapositivas en `Quarto` disponibles y actualizadas en **<https://javieralvarezliebana.es/cursos-R/RTVE-formacion/diapos/#/title-slide>**. En el men√∫ de las diapositivas (abajo a la izquierda) tienes una [**opci√≥n para descargarlas en pdf**]{.hl-yellow} en `Tools`
  
&nbsp;

* [**Material**]{.hl-yellow}: [**cuadernos de trabajo**](https://javieralvarezliebana.quarto.pub/workbook-rtve) y materiales extras y **res√∫menes de paquetes**

* [üóÉ **Datos**]{.hl-yellow}: datasets que usaremos a lo largo de la asignatura, disponibles en Github **<https://github.com/dadosdelaplace/cursos-R/tree/main/RTVE-formacion/diapos/datos>**

* [üìö **Recursos de apoyo**]{.hl-yellow}: en ingl√©s <https://r4ds.had.co.nz/> y en castellano <https://cdr-book.github.io/>, y <https://ivelasq.quarto.pub/intro-to-quarto/> para Quarto.


# Clase 1: [welcome to R again]{.flow} {#clase-1}

[**Refrescando R**]{style="color:#444442;"}

* [Reminders](#reminders)
* [Tidy data](#tidy-data)
* [Preprocesamiento: dplyr](#tidy-data)


---

## Reminder: ¬øpor qu√© programar? {#reminders}

-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes.

-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Reminder: requisitos

Por si se te hab√≠a olvidado, para el curso los √∫nicos requisitos ser√°n:

1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de algunos datos y paquetes).

. . .

2.  [**Instalar R**]{.hl-yellow}: ser√° nuestro lenguaje. La descarga la haremos (gratuitamente) desde <https://cran.r-project.org/>

. . .

3.  [**Instalar RStudio**]{.hl-yellow} desde <https://posit.co/download/rstudio-desktop/>


::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="420"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="420"}
:::
:::

---

## Reminder: R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::

::: {.fragment .fade-in-then-out}
Programaremos como escribimos (castellano, por ejemplo) ‚Üí `R` es [**lenguaje**]{.hl-yellow}
:::

::: {.fragment .fade-up}
-   Necesitaremos una [**gram√°tica, un lenguaje**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}
-   Y un entorno, por ejemplo un [**Word**]{.hl-yellow} (`RStudio`), para escribirlo
:::
:::

---


## Reminder: asignaci√≥n, ¬øigual?, argumentos

No se si recuerdas que en `R` vamos a distinguir [**tres tipos de ¬´igual¬ª**]{.hl-yellow}:

* [**Asignaci√≥n**]{.hl-yellow}: usaremos `<-` para asignar el valor de la derecha a la variable cuyo nombre tenemos a la izquierda


```{r}
a <- c(1, 2)
```

* [**Comparaci√≥n l√≥gica**]{.hl-yellow}: usaremos `==` para preguntar si lo de la izquierda es igual a lo de la derecha (la respuesta ser√° un vector l√≥gico)


```{r}
a == 1
```


* [**Argumentos**]{.hl-yellow}: usaremos `=` para asignar argumentos dentro de una funci√≥n


```{r}
mean(x = a, na.rm = TRUE)
```


---


## Reminder: errores y warning

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-orange}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```


---

## Reminder: proyectos

De la misma manera que en el ordenador solemos trabajar de manera [**ordenada por carpetas**]{.hl-yellow}, en `RStudio` podemos hacer lo mismo para trabajar de [**manera eficaz creando proyectos**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}
Un [**proyecto ser√° una ¬´carpeta¬ª**]{.hl-yellow} dentro de `RStudio`, de manera que nuestro directorio ra√≠z autom√°ticamente ser√° la propia carpeta de proyecto (pudiendo pasar de un proyecto a otro con el menu superior derecho).

Podemos crear uno en una carpeta nueva o en una carpeta ya existente.
:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---


## Reminder: tipos de datos

¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg)

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores en R**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Reminder: tipos de datos

¬øExisten [**variables m√°s all√° de los n√∫meros**]{.hl-yellow}? Piensa por ejemplo en los datos que podr√≠as guardar de una persona:

::: {.fragment .fade-up}
-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre ser√° una cadena de [**texto (conocida como string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta ¬´¬øest√°s matriculado en la Facultad?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° matriculado o `FALSE` en otro caso).

```{r}
matriculado <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.

```{r}
birth_day <- lubridate::as_date("1989-09-10")
```
:::

---

## Reminder: tipos de datos



Imagina que adem√°s de la edad de una persona queremos guardar su nombre: ahora la variable ser√° de tipo `character`

```{r}
nombre <- "Javier"
class(nombre)
```

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones aritm√©ticas**]{.hl-red} (s√≠ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar n√∫mero a texto
```

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o string) van [**SIEMPRE entre comillas**]{.hl-orange}: no es lo mismo `TRUE` (valor l√≥gico, binario) que `"TRUE"` (texto).
:::

---

## Reminder: tipos de datos

Otro tipo fundamental ser√°n las [**variables l√≥gicas o binarias**]{.hl-yellow} (**dos valores**):

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```

. . .

Dado que internamente est√°n guardados como variables binarias, podemos [**realizar operaciones aritm√©ticas**]{.hl-yellow} con ellas

```{r}
2 * TRUE
FALSE - 1
```

---

## Reminder: tipos de datos

Las variables l√≥gicas en realidad puede tomar un tercer valor: `NA` o [**dato ausente**]{.hl-yellow}, representando las siglas de *not available*, y ser√° muy habitual encontrarlo dentro de una base de datos.

```{r}
ausente <- NA
ausente + 1
```


. . .

::: callout-important
## Importante

Las variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor l√≥gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Reminder: tipos de datos

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

Parece una simple cadena de texto pero [**deber√≠a representar un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

. . .

```{r}
#| error: true
fecha_char + 1
```


Las fechas [**NO pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha. Para trabajar con fechas usaremos el paquete `{lubridate}`, que deberemos instalar antes de poder usarlo.


```{r}
#| eval: false
install.packages("lubridate")
```


---

## Reminder: vectores

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de celdas (valores) del [**mismo tipo**]{.hl-purple} (lo que ser√≠a una columna de una tabla).

. . .

La forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus **elementos entre par√©ntesis y separados por comas**

```{r}
edades <- c(32, 27, 60, 61)
edades
```

. . .


La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

---

## Reminder: secuencias

El vector m√°s famoso ser√° el de tipo num√©rico, y en concreto, las conocidas como [**secuencias num√©ricas**]{.hl-yellow}. El comando `seq(inicio, fin)` nos permite crear una [**secuencia num√©rica**]{.hl-yellow} desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 21)
```

. . .

Un atajo es el comando `1:n`, que nos devuelve lo mismo que `seq(1, n)`

```{r}
1:7
```

. . .

Tambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos con el argumento `by = ...` o su longitud con `l = ...`

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
seq(1, 10, l = 7) # secuencia desde 1 a 50 de longitud 7
```


---


## Reminder: vectores

Con los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros ‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)

. . .

¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Reminder: vectores


Una operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida (de **igual longitud** que el vector preguntado)

. . .

Si tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Reminder: vectores

Las [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Reminder: vectores

Otra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow}. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .


Dado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qu√©", "tal", "est√°s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

. . .

::: callout-tip
Para acceder al √∫ltimo, sin preocuparnos de cu√°l es, podemos pasarle como √≠ndice la propia longitud `x[length(x)]`
:::

---

## Reminder: vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª

```{r}
y
y[-2]
```


. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "mar√≠a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---


## Reminder: vectores


Tambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Reminder: vectores


Por √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## Reminder: bases de datos

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile.


* La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}. La opci√≥n m√°s habitual es usando `cbind()`: [**concatenamos (bind) vectores en forma de columnas (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
estaturas <- c(150, 160, 170, 180)
pesos <- c(63, 70, 85, 95)
datos_matriz <- cbind(estaturas, pesos)
datos_matriz
```

---

## Reminder: bases de datos

Dado que ahora tenemos dos dimensiones en nuestros datos, para [**acceder a elementos con `[]`**]{.hl-yellow} deberemos proporcionar **dos √≠ndices separados por comas**: √≠ndice de la fila y de la columna 

```{r}
datos_matriz[2, 1] # segunda fila, primera columna
datos_matriz[1, 2] # primera fila, segunda columna 
datos_matriz[2, ] # segundo individuo
datos_matriz[, 1] # primera variable
```

---

## Reminder: bases de datos

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
matriz <- cbind(edades, soltero, nombres)
matriz
```

. . .

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} tenemos en `R` lo que se conoce como [**data.frame**]{.hl-yellow}: concatenaci√≥n de variables de igual longitud pero que pueden ser de [**tipo distinto**]{.hl-purple}.

```{r}
tabla <- data.frame(edades, soltero, nombres)
tabla
```

---

## Reminder: bases de datos

Si queremos acceder a sus elementos, al ser de nuevo **datos tabulados**, podemos acceder como en las matrices ([**no recomendable**]{.hl-red}): de nuevo [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}
Pero tambi√©n tiene las ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} ([**lo recomendable**]{.hl-green} ya que las variables pueden cambiar de posici√≥n y ahora s√≠ tienen un significado), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

---

## Reminder: bases de datos

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}. La principal es que [**no permite la recursividad**]{.hl-red}. En adelante usaremos el formato `tibble` ([**data.frame mejorado**]{.hl-yellow}) del paquete `{tibble}`

```{r}
library(tibble)
datos_tb <- 
  tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
         "IMC" = peso / (estatura^2))
class(datos_tb)
datos_tb
```

---


## üíª Tu turno {#tu-turno-1-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares. Calcula la longitud del vector

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Accede al tercer elemento de `x`. Accede al √∫ltimo elemento (sin importar la longitud, un c√≥digo que pueda ejecutarse siempre). Elimina el primer elemento.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Obt√©n los elementos de `x` mayores que 4. Calcula el vector `1/x` y gu√°rdalo en una variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Crea un vector que represente los nombres de 5 personas, de los cuales uno es desconocido.

```{r}
#| code-fold: true
#| eval: false
nombres <- c("Javi", "Sandra", NA, "Laura", "Carlos")
nombres
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Encuentra del vector `x` de ejercicios anteriores los elementos mayores (estrictos) que 1 Y ADEM√ÅS menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```



### [**Ejercicio 6**]{.hl-yellow}

üìù Dado el vector `x` del ejercicio anterior, ¬øcuales tienen un dato ausente? Pista: las funciones `is.algo()` comprueban si el elemento es tipo `algo` (tabula)

```{r}
#| code-fold: true
#| eval: false
is.na(x)
```



### [**Ejercicio 7**]{.hl-yellow}

üìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor) de las dos formas posibles

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```


### [**Ejercicio 8**]{.hl-yellow}

üìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 6. Encuentra una forma de averiguar si todos los elementos son o no negativos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```



### [**Ejercicio 9**]{.hl-yellow}

üìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (variables de la calidad del aire de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 10**]{.hl-yellow}

üìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Ejercicio 11**]{.hl-yellow}

üìù Cambia el c√≥digo inferior para filtrar solo los datos de la quinta observaci√≥n

```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Ejercicio 12**]{.hl-yellow}

üìù Cambia el c√≥digo inferior para filtrar solo los datos del mes de agosto.


```{r}
#| eval: false
airquality_tb[Month == 8, ]
```

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]
```


:::


---


## üê£ Caso pr√°ctico I: manejo de vectores {#caso-practico-1-1}

En el paquete `{datasets}` (ya instalado por defecto) tenemos diversos conjuntos de datos y uno de ellos es `airquality`. 

Los datos capturan [**medidas diarias (n = 153 observaciones) de la calidad del aire**]{.hl-yellow} en Nueva York, de mayo a septiembre de 1973. Se midieron **6 variables**: niveles de ozono, radiaci√≥n solar, viento, temperatura, mes y d√≠a.

```{r}
#| eval: false
library(datasets)
airquality
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-i-airquality-manejo-de-vectores)


---

## ¬øQu√© era tidyverse? {#tidy-data}

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

En ese contexto de programaci√≥n funcional, hace una d√©cada nac√≠a `{tidyverse}`, un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garantizar un flujo de trabajo eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}

---

## ¬øQu√© era tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n

:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaci√≥n de datos



:::
:::



---

## ¬øQu√© era tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

-   `{lubridate}` manejo de fechas
-   `{rvest}`: web scraping
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n


:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: carga datos rectangulares (.csv), `{readxl}` para importar archivos .xls y .xlsx
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{purrr}`: manejo de listas
-   `{forcats}`: manejo de cualitativas
-   `{ggplot2}`: visualizaci√≥n de datos

:::
:::


---

## Filosof√≠a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducida por **Hadley Wickham** (el Dios al que rezamos) de [**estandarizar**]{.hl-yellow} el formato de los datos para

::: incremental
-   [**sistematizar**]{.hl-green} la depuraci√≥n
-   hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.
-   c√≥digo [**legible**]{.hl-green}
:::

---

## Reglas del tidy data

Lo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna com√∫n**]{.hl-purple}
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Tuber√≠a (pipe)

En `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}
En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```
:::
:::


. . .

::: callout-caution
## Apunte importante

Desde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo** disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).
:::

---

## Tuber√≠a (pipe)

La principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## Datos SUCIOS: messy data

¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).


```{r}
library(tidyr)
table4a
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}
‚ùé Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
:::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```

---

## Pivotar: pivot_longer()

::: columns
::: {.column width="50%"}
```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```
:::

::: {.column width="50%"}
![](img/table4a.jpg)
:::
:::



-   `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
-   `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
-   `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`


```{r}
table2
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_wider()

::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}
‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}
:::
:::

. . .

Lo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`


```{r}
table3
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Separar: separate()

::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}
‚ùé Cada [**celda contiene varios valores**]{.hl-red}
:::
:::

. . .

Lo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

F√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el √∫ltimo ejemplo con la tabla `table5`


```{r}
table5
```


[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Unir unite()

::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}
‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red}
:::
:::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## Ejemplo: relig_income

Vamos a realizar un ejemplo juntos con la tabla `relig_income` del paquete `{tidyr}`. Como se indica en la ayuda `? relig_income`, la tabla representa la cantidad de personas que hay en cada tramo de ingresos anuales (20k = 20 000$) y en cada religi√≥n.

```{r}
relig_income
```

---

## Ejemplo: relig_income

```{r}
relig_income
```

[**¬øEs tidydata?**]{.hl-yellow} 

---

## Ejemplo: relig_income

```{r}
relig_income
```

No lo es ya que en realidad [**solo deber√≠amos tener una variable de ingresos**]{.hl-red} y la tenemos dividida en 11: todas ellas es la misma variable solo que adopta un valor diferente.  [**¬øC√≥mo convertirla a tidy data?**]{.hl-green}

---

## Ejemplo: relig_income


La idea es [**pivotar todas las columnas de ingresos**]{.hl-yellow} para que acaben en una sola columna llamada `income`, y los valores (el n√∫mero de personas) en otra llamada `people` (por ejemplo). La tabla la haremos m√°s larga y menos ancha as√≠ que...

. . .

```{r}
relig_tidy <-
  relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused", names_to = "income",
               values_to = "people")
relig_tidy 
```

---

## Ejemplo: relig_income

Vamos a hilar m√°s fino: ahora mismo en la variable `income` en realidad tenemos dos valores, el l√≠mite inferior y el superior de la renta. Vamos a [**separar dicha variable e ingresos**]{.hl-yellow} en dos, llamadas `income_inf` y `income_sup`

```{r}
#| code-fold: true
relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-")
```

. . .

¬øEst√° ya ok? F√≠jate bien...

---

## Ejemplo: relig_income

Si te fijas la primera columna el `"$10k"` deber√≠a ser una cota superior, no inferior. ¬øC√≥mo indicarle que separe bien ese caso?

. . .

Le indicaremos que separe si encuentra `"-"` o `"<"` (usamos `|` para separar ambas opciones)

```{r}
#| code-fold: true
relig_tidy <-
  relig_tidy |>
  # Separamos por -
  separate(income, into = c("income_inf", "income_sup"), sep = "-|<")
```

---

## Ejemplo: relig_income


Piensa ahora como podemos [**convertir los l√≠mites de ingresos a num√©ricas (eliminando s√≠mbolos, letras, etc)**]{.hl-yellow}

. . .

Para ello usaremos el paquete `{stringr}`, en concreto la funci√≥n `str_remove_all()` a la que le podemos pasar los caracteres que queremos eliminar (f√≠jate que `$` al ser un caracter reservado en `R` hay que indic√°rselo con `\\$`)

```{r}
#| code-fold: true
library(stringr)
relig_tidy$income_inf <-
  str_remove_all(relig_tidy$income_inf, "\\$|>|k")
relig_tidy$income_sup <-
  str_remove_all(relig_tidy$income_sup, "\\$|>|k")

relig_tidy
```


---

## üíª Tu turno {#tu-turno-1-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}


üìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```


### [**Ejercicio 2**]{.hl-yellow}

üìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù En el paquete `{tidyr}` contamos con el dataset `who2` (dataset de la Organizaci√≥n Mundial de la Salud). ¬øEs tidy data? ¬øPor qu√©? Convierte a tidy data

```{r}
#| code-fold: true
who_tidy <-
  who2 |> 
  # con values_drop_na = TRUE eliminamos los NA
  pivot_longer(cols = -(country:year), names_to = "type",
               values_to = "cases", values_drop_na = TRUE)
who_tidy
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Si te fijas ahora en type tenemos codificada la informaci√≥n como diagnosis_sexo_edad. ¬øC√≥mo separarlo en 3 columnas? Investiga tanto `separate()` como las opciones de `pivot_longer()`

```{r}
#| code-fold: true
# con separate
who_tidy <-
  who_tidy |> 
  separate(col = "type", into = c("diagnosis", "sex", "age"))

# con pivot_longer
who_tidy <-
  who2 |> 
  pivot_longer(cols = -(country:year),
               names_to = c("diagnosis", "sex", "age"),
               values_to = "cases", values_drop_na = TRUE, names_sep = "_")
who_tidy
```


### [**Ejercicio 5**]{.hl-yellow}

üìù Por √∫ltimo, separa en dos (age_inf, age_sup) el tramo etario (que sean n√∫meros). Piensa c√≥mo hacerlo ya que no siempre son 4 n√∫meros

```{r}
#| code-fold: true
# Usamos separate y le indicamos las posiciones, pero desde atr√°s 
# ya que siempre el l√≠mite superior es un n√∫mero de 2 cifras
# y usamos convert = TRUE para convertir a n√∫meros
who_tidy <-
  who_tidy |> 
  separate(col = "age", into = c("age_inf", "age_sup"),
           sep = -2, convert = TRUE)
```

:::

---

## üê£ Caso pr√°ctico II: tidydata {#caso-practico-1-2}


En el fichero `messy_covid_data.csv` tienes un archivo con la cantidad de casos reportados durante la pandemia covid pero en **formato messy**: el nombre de las columnas codifica el sexo (H hombre, M mujer, NC no consta) y el grupo etario (0-9, 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70-79, ‚â•80 a√±os y NC no consta). Las soluciones ser√°n asumiendo que no se conoce a√∫n las opciones de tidyverse para modificar y filtrar tablas.

&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-ii-covid-tidy-data)

---

## Preprocesamiento: dplyr {#dplyr}

Como vimos dentro de `{tidyverse}` tenemos el paquete `{dplyr}` para el [**preprocesamiento y depuraci√≥n**]{.hl-yellow} de los datos.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
:::

La idea es que el [**c√≥digo sea legible**]{.hl-yellow}, como si fuese una **lista de instrucciones** que al leerla nos diga de manera muy evidente lo que est√° haciendo.

---

## Preprocesamiento: dplyr

Vamos a repasar con el dataset `accidentes2020_data` del paquete `{CDR}` que recopila los **datos de accidentes de tr√°fico** con v√≠ctimas y/o da√±os al patrimonio en la ciudad de Madrid registrados por la Polic√≠a Municipal durante 2020.

```{r}
accidentes_tb <- as_tibble(CDR::accidentes2020_data)
accidentes_tb
```

---

## Muestreo

:::: columns
::: {.column width="60%"}

Una de las operaciones m√°s comunes es lo que se conoce en estad√≠stica como [**muestreo**]{.hl-yellow}: una [**selecci√≥n o filtrado de registros**]{.hl-yellow} (una submuestra)

:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**No aleatorio (por cuotas)**]{.hl-purple}: en base a condiciones l√≥gicas sobre los registros (`filter()`)

. . .

* [**No aleatorio (intencional/discreccional)**]{.hl-purple}: en base a posici√≥n (`slice()`)

. . .

* [**Aleatorio simple**]{.hl-purple} (`slice_sample()`)

. . .

* [**Aleatorio estratificado**]{.hl-purple} (`group_by()` + `slice_sample()`)


---

## Filtrar filas: filter()

El muestreo m√°s simple es cuando [**filtramos registros**]{.hl-yellow} en base a alguna condici√≥n l√≥gica: con `filter()` se seleccionar√°n solo individuos que cumplan ciertas condiciones

¬øCu√°les son los **accidentes que se produjeron en Carabanchel**?

. . .

```{r}
library(dplyr)
accidentes_tb |> 
  filter(distrito == "CARABANCHEL")
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes ocurridos el 31 de diciembre?

. . .

```{r}
library(lubridate)
accidentes_tb |> 
  filter(as_date(fecha, format = "%d/%m/%Y") == "2020/12/31")
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes ocurridos en diciembre en el que hay mujeres conductoras involucradas?

. . .

```{r}
accidentes_tb |> 
  filter(month(as_date(fecha, format = "%d/%m/%Y")) == 12 &
           tipo_persona == "Conductor" & sexo == "Mujer")
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes cuando hubo granizo, lluvia (intensa o d√©bil) o nieve?

. . .

```{r}
accidentes_tb |> 
  filter(estado_meteorol√≥gico %in%
           c("Granizando", "LLuvia intensa", "Lluvia d√©bil", "Nevando"))
```

---

## Filtrar filas: filter()

¬øCu√°les fueron los accidentes cuya lesividad se sit√∫a entre 1 y 3 (ambos inclusive)?

. . .

```{r}
accidentes_tb |> 
  filter(between(as.numeric(lesividad), 1, 3))
```



---

## Filtrar filas: filter()

Las [**condiciones l√≥gicas**]{.hl-yellow} las podemos [**combinar**]{.hl-yellow} de diferentes maneras (y, o, o excluyente)

![](img/tablas_verdad.png)

. . .


::: callout-tip
## Importante

Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores l√≥gicos**]{.hl-green}.
:::


---

## Eliminar ausentes

¬øCu√°les fueron los accidentes en los que el sexo de la persona involucrada es desconocido?

. . .

Los [**ausentes deber√≠an estar codificados como `NA`**]{.hl-yellow}, y usar `drop_na()` para depurarlos, pero no siempre van a estar ya codificados as√≠.

```{r}
accidentes_tb |> 
  filter(sexo == "Desconocido")
```


---

## Rebanadas de datos: slice()

A veces nos puede interesar realizar un [**muestreo no aleatorio discreccional**]{.hl-yellow}, o lo que es lo mismo, [**filtrar por posici√≥n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concretas pasando como argumento un [**vector de √≠ndices**]{.hl-yellow}


¬øCu√°les son los **7 primeros accidentes guardados** en la base de datos?

. . .

```{r}
accidentes_tb |> 
  slice(1:7)

# otra forma:
# accidentes_tb |> 
#   slice_head(n = 7)
```


---

## Rebanadas de datos: slice()

¬øCu√°les fueron los **primeros 100 accidentes** del a√±o (usando fecha y hora)?

. . .

```{r}
accidentes_tb |> 
  slice_min(dmy_hms(paste(fecha, hora)), n = 100)
```


---

## Rebanadas de datos: slice()

¬øCu√°les fue el **√∫ltimo accidente** del a√±o (usando fecha y hora)?

. . .

```{r}
accidentes_tb |> 
  slice_max(dmy_hms(paste(fecha, hora)), n = 1)
```


---

## Aleatorio: slice_sample()


El conocido como [**muestreo aleatorio simple**]{.hl-yellow} se basa en [**seleccionar individuos aleatoriamente**]{.hl-yellow}, de forma que cada uno tenga ciertas [**probabilidades**]{.hl-yellow} de ser seleccionado. Con `slice_sample(n = ...)` o `slice_sample(prop = ...)` podemos extraer n registros aleatoriamente (a priori equiprobables).


**Extrae el 10%** de la muestra de manera aleatoria

. . .

```{r}
accidentes_tb |> 
  slice_sample(prop = 0.1)
```


---

## Aleatorio: slice_sample()


::: callout-important
## Importante...

[**¬´Aleatorio¬ª no implica equiprobable**]{.hl-yellow}: es igual de aleatorio un dado normal que uno trucado. No hay cosas ¬´m√°s aleatorias¬ª que otras, simplemente tienen subyacente distintas leyes de probabilidad.

:::

**Extrae el 10% de la muestra de manera aleatoria pero** siendo m√°s probable de muestrear a los accidentes en los primeros d√≠as de mes

. . .

```{r}
accidentes_tb |> 
  slice_sample(prop = 0.1, weight_by = day(dmy(fecha)))
```


---


## Reordenar filas: arrange()


Tambi√©n podemos [**ordenar filas**]{.hl-yellow} en funci√≥n de alguna variable con `arrange()`

**Ordena** los accidentes por fecha

. . .

```{r}
accidentes_tb |> 
  arrange(dmy(fecha))
```


---

## Eliminar duplicados: distinct()

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`.


**Elimina los duplicados** considerando duplicados aquellos registros con mismo `num_expediente`, mismo `tipo_accidente` y mismo `tipo_persona`

. . .

```{r}
accidentes_tb |>
  distinct(num_expediente, tipo_accidente, tipo_persona)
```

---


## Selecci√≥n columnas: select()

Hasta ahora todas las operaciones realizadas (aunque us√°semos info de columnas) eran por filas. En el caso de columnas, la acci√≥n m√°s sencilla es [**seleccionar variables por nombre**]{.hl-yellow} con `select()`, dando como argumentos los nombres de columnas [**sin comillas**]{.hl-purple}.

**Selecciona solo las columnas** `num_expediente`, `fecha`, `hora`, `distrito`, `tipo_persona`, `rango_edad` y `sexo`.

. . .

```{r}
accidentes_tb |> 
  select(num_expediente:hora, distrito, tipo_persona:sexo)
```


---

## Selecci√≥n columnas: select()

**Elimina la columna** `localizacion`.

. . .

```{r}
accidentes_tb |> 
  select(-localizacion)
```


---


## Selecci√≥n columnas: select()

Tambi√©n podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen/termina por un patr√≥n**]{.hl-purple}, que lo contengan o que cumplan una [**expresi√≥n regular**]{.hl-purple} (`matches()`).


**Selecciona las columnas** `num_expediente`, `fecha`, `hora` y aquellas que apelen a coordenas o a `tipo_`.

. . .

```{r}
accidentes_tb |> 
  select(num_expediente, fecha, hora, starts_with("coordenada"), 
         starts_with("tipo_"))
```



---

## Selecci√≥n columnas: select()


Tambi√©n podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funci√≥n que devuelva un valor l√≥gico de tipo de dato.

**Selecciona las columnas** de tipo character.

. . .

```{r}
accidentes_tb |> 
  select(where(is.character))
```


---

## Renombrar: rename()


A veces tambi√©n podemos querer [**modificar la ¬´metainformaci√≥n¬ª**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.


**Renombra las columnas** `num_expediente` como `numero_exp`

. . .

```{r}
accidentes_tb |> 
  rename(numero_exp = num_expediente)
```

---


## Modificar columnas: mutate()

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. 

Haciendo uso de las funciones de `{lubridate}` **crea una nueva columna** llamada `fecha_hora` que guarde la fecha y hora en un formato fecha-hora (`datetime`) y elimina dichas variables originales

. . .

```{r}
accidentes_tb |> 
  mutate("fecha_hora" = dmy_hms(paste(fecha, hora)), .after = num_expediente) |> 
  select(-fecha, -hora)
```

---


## Modificar columnas: mutate()


**Modifica la columna** `numero` que ya existe para convertirla a tipo numeric.

```{r}
accidentes_tb <-
  accidentes_tb |> 
  mutate("numero" = as.numeric(numero))
accidentes_tb
```


---

## Modificar columnas: mutate()

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funci√≥n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolver√° una constante**]{.hl-red}
:::

```{r}
#| message: false
#| warning: false
accidentes_tb |> 
  mutate("dummy" = mean(numero, na.rm = TRUE),
         .before = everything())
```


---

## Recategorizar


**Recodifica** la variable sexo tal que si no se conoce su valor se incluye `NA`

. . .

```{r}
accidentes_tb |> 
  mutate("sexo" = if_else(sexo == "Desconocido", NA, sexo)) |> 
  select(num_expediente, sexo)
```

---

## Recategorizar


**Recodifica** la variable `estado_meteorol√≥gico` para dejar solo `"Despejado"`, `"Precipitaci√≥n"` (incluye lluvia, nieve, granizo), `"Nublado"` y `NA`

. . .

```{r}
accidentes_tb |> 
  mutate("estado_meteorol√≥gico" =
           case_when(estado_meteorol√≥gico == "Despejado" ~ "Despejado",
                     estado_meteorol√≥gico %in%
                       c("Granizando", "Lluvia intensa",
                         "Lluvia d√©bil", "Nevando") ~ "Precipitaci√≥n",
                     estado_meteorol√≥gico == "Nublado" ~ "Nublado",
                     TRUE ~ NA)) |> 
  select(num_expediente, estado_meteorol√≥gico)
```


---


## Contar: count()


Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estad√≠sticas. Empecemos por lo sencillo: [**¬øc√≥mo contar (frecuencias)?**]{.hl-yellow}


¬øCu√°ntos accidentes hay guardados de cada sexo? 

. . .


```{r}
accidentes_tb |> 
  count(sexo, sort = TRUE)
```

---

## Contar: count()


¬øQu√© % del total representa cada sexo?


. . .

```{r}
accidentes_tb |> 
  count(sexo, sort = TRUE) |> 
  mutate("prop" = n/sum(n))
```

. . .

```{r}
# modo R base
prop.table(table(accidentes_tb$sexo))
```



---

## Contar: count()

¬øCu√°ntos accidentes hubo para cada sexo y cada tipo de persona (conductor, peat√≥n, etc)?

. . .

```{r}
accidentes_tb |> 
  count(sexo, tipo_persona, sort = TRUE)
```

---

## Agrupar: group_by()


¬øCu√°l fueron los primeros accidente del a√±o por cada sexo?

. . .

```{r}
accidentes_tb |> 
  slice_min(dmy_hms(paste(fecha, hora)), n = 1, by = sexo,
            with_ties = FALSE)
```

---

## Agrupar: group_by()


Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} que modificar√° las acciones futuras.

¬øCu√°l fue el accidente m√°s lesivo por cada tipo de persona y sexo?

. . .

```{r}
accidentes_tb |> 
  slice_max(lesividad, n = 1, by = c(sexo, tipo_persona))
```


---


## Resumir: summarise()


Por √∫ltimo tenemos `summarise()`, que nos permitir√° sacar res√∫menes estad√≠sticos. 


**Calcula la media** de accidentes diarios por sexo

. . .


```{r}
accidentes_tb |> 
  count(sexo, fecha) |> 
  summarise("media_diaria" = mean(n), .by = sexo)
```

---

## Resumir: summarise()


::: callout-warning
## Cuidado

F√≠jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que est√© indicado.
:::


**Calcula la media de lesividad** de los accidentes por tipo de persona

. . .


```{r}
accidentes_tb |>
  mutate("lesividad" = as.numeric(lesividad)) |> 
  drop_na(lesividad) |> 
  summarise("media_lesividad" = mean(lesividad), .by = tipo_persona)
```


---

## Resumir: reframe()


En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos m√°s de un valor por variable**]{.hl-yellow}.


**Calcula los cuartiles de la variables lesividad** 

. . .


```{r}
accidentes_tb |> 
  mutate("lesividad" = as.numeric(lesividad)) |> 
  drop_na(lesividad) |> 
  reframe(quantile(lesividad))
```

---

## Tip: percent_rank()


La funci√≥n `percent_rank()` es bastante √∫til para, dada una variable, calcular en qu√© [**percentil se sit√∫a cada observaci√≥n**]{.hl-yellow} (de 0 a 1: si 0.468, ese registro para dicha variable ocupa el percentil 46.8%).

```{r}
accidentes_tb |> 
  mutate("lesividad" = as.numeric(lesividad)) |> 
  drop_na(lesividad) |> 
  mutate("lesividad_rank" = percent_rank(lesividad)) |> 
  select(num_expediente, lesividad, lesividad_rank)
```


---


## Relacionando datos

Al trabajar con datos [**no siempre tendremos la informaci√≥n en una sola tabla**]{.hl-yellow} y a veces nos interesar√° cruzar la informaci√≥n de distintas fuentes.

. . .

Para ello usaremos un cl√°sico de todo lenguaje que maneja datos: los famosos [**join**]{.hl-yellow}, que nos permitir√°n [**cruzar una o varias tablas**]{.hl-yellow}, haciendo uso de una [**columna identificadora**]{.hl-yellow} de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo `join` por la columna `DNI`).

---

## Relacionando datos

La estructura b√°sica es la siguiente:

```{r}
#| eval: false
tabla_1 |>
  xxx_join(tabla_2, by = id)
```

![](img/sql-joins.jpg)

. . .


Vamos a probar los distintos joins con un ejemplo sencillo

```{r}
tb_1 <- tibble("key" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

:::: columns
::: {.column width="50%"}

```{r}
tb_1
```

:::

::: {.column width="50%"}

```{r}
tb_2
```

:::
::::

---

## Left join


* `left_join()`: mantiene [**todos los registros de la primera tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la segunda (en caso de [**no tenerlo se rellena con NA**]{.hl-yellow} los campos de la 2¬™ tabla).

En nuestra caso queremos incorporar a `tb_1` la informaci√≥n de `tb_2`, identificando los registros por la columna key (`by = "key"`, la columna por la que tiene que cruzar)

:::: columns
::: {.column width="50%"}


```{r}
tb_1  |> 
  left_join(tb_2, by = "key")
```

:::
::: {.column width="50%"}


![](img/left_join.jpg)


:::
::::

---

## Left join

```{r}
tb_1 |> 
  left_join(tb_2, by = "key")
```

F√≠jate que los [**registros de la primera cuya key no ha encontrado en la segunda**]{.hl-yellow} les ha dado el valor de [**ausente**]{.hl-yellow}.

---



## Right join


* `right_join()`: mantiene [**todos los registros de la segunda tabla**]{.hl-yellow}, y busca cuales tienen id tambi√©n en la primera.


Vamos ahora a incorporar a `tb_2` la informaci√≥n de `tb_1`, identificando los registros por la columna key (`by = "key"`)

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

:::

::: {.column width="50%"}

![](img/right_join.jpg)

:::
::::

---

## Right join


```{r}
tb_1 |> 
  right_join(tb_2, by = "key")
```

F√≠jate que ahora los [**registros de la segunda cuya key no ha encontrado en la primera**]{.hl-yellow} son los que les ha dado el valor de [**ausente**]{.hl-yellow}.

---


## Claves y sufijos

Las columnas clave que usaremos para el cruce [**no siempre se llamar√°n igual**]{.hl-yellow}.

```{r}
tb_1 <- tibble("key_1" = 1:3, "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val_y" = c("y1", "y2", "y3"))
```

. . .

* `by = c("key_2" = "key_2")`: le indicaremos en qu√© columna de cada tabla est√°n las claves por las que vamos a cruzar.

:::: columns
::: {.column width="50%"}

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

```{r}
# Right
tb_1  |> 
  right_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---

## Claves y sufijos

Adem√°s podemos [**cruzar por varias columnas a la vez**]{.hl-yellow} (interpretar√° como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`. Modifiquemos el ejemplo anterior

```{r}
tb_1 <- tibble("k_11" = 1:3, "k_12" = c("a", "b", "c"),  "val_x" = c("x1", "x2", "x3"))
tb_2 <- tibble("k_21" = c(1, 2, 4), "k_22" = c("a", "b", "e"), "val_y" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2,
            by = c("k_11" = "k_21", "k_12" = "k_22"))
```


---

## Claves y sufijos

Tambi√©n podr√≠a suceder que al cruzar dos tablas, haya [**columnas de valores que se llamen igual**]{.hl-yellow}


```{r}
tb_1 <- tibble("key_1" = 1:3, "val" = c("x1", "x2", "x3"))
tb_2 <- tibble("key_2" = c(1, 2, 4), "val" = c("y1", "y2", "y3"))
```

. . .

```{r}
# Left
tb_1 |> 
  left_join(tb_2, by = c("key_1" = "key_2"))
```

F√≠jate que [**por defecto nos a√±ade los sufijos**]{.hl-yellow} `.x` y `.y` para indicarnos de que tabla vienen.

---

## Claves y sufijos


Dicho [**sufijo podemos especific√°rselo**]{.hl-yellow} en el argumento opcional `suffix = ...`, que nos permita [**distinguir las variables**]{.hl-yellow} de una tabla y de otra.


```{r}
# Left
tb_1 |>
  left_join(tb_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla2"))
```


---


## Full join


* `full_join()`: mantiene [**todos los registros de ambas**]{.hl-yellow} tablas.

Los dos anteriores casos forman lo que se conoce como [**outer joins**]{.hl-yellow}: cruces donde se mantienen observaciones que salgan en al menos una tabla. El tercer outer join es el conocido como `full_join()` que nos [**mantendr√° las observaciones de ambas**]{.hl-yellow} tablas, [**a√±adiendo las filas**]{.hl-yellow} que no casen con la otra tabla.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  full_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/full_join.jpg)

:::
::::


---

## Inner join

* `inner_join()`: solo sobreviven los [**registros cuyo id est√© en ambas**]{.hl-yellow} tablas.

Frente a los outer join est√° lo que se conoce como [**inner join**]{.hl-yellow}, con `inner_join()`: un cruce en el que solo se mantienen las [**observaciones que salgan en ambas tablas**]{.hl-yellow}, solo mantiene aquellos registros matcheados.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::


::: {.column width="50%"}

![](img/inner_join.png)


:::
::::

---

## Inner join

F√≠jate que en t√©rminos de registros, `inner_join` si es conmutativa, **nos da igual el orden de las tablas**: lo √∫nico que cambia es el orden de las columnas que a√±ade.

:::: columns
::: {.column width="50%"}


```{r}
tb_1 |> 
  inner_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}


```{r}
tb_2 |> 
  inner_join(tb_1, by = c("key_2" = "key_1"))
```

:::
::::

---

## Anti/semi join

Por √∫ltimo tenemos dos herramientas interesantes para [**filtrar (no cruzar) registros**]{.hl-yellow}: `semi_join()` y `anti_join()`. El [**semi join**]{.hl-yellow} nos deja en la [**primera tabla los registros que cuya clave est√° tambi√©n en la segunda**]{.hl-yellow} (como un inner join pero sin a√±adir la info de la segunda tabla). Y el segundo, los anti join, hace justo lo contrario (aquellos que no est√°n).


:::: columns
::: {.column width="50%"}

```{r}
# semijoin
tb_1 |> 
  semi_join(tb_2, by = c("key_1" = "key_2"))
```

:::

::: {.column width="50%"}

```{r}
# antijoin
tb_1 |> 
  anti_join(tb_2, by = c("key_1" = "key_2"))
```

:::
::::


---


## üíª Tu turno {#tu-turno-1-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Vamos a realizar un [**an√°lisis de las canciones Taylor Swift**]{.hl-yellow} haciendo uso del paquete `{taylor}`


```{r}
library(taylor)
taylor_album_songs
```
¬øCu√°ntas canciones hay guardadas? ¬øCu√°ntas caracter√≠sticas de cada una?

```{r}
#| code-fold: true
#| eval: false
taylor_album_songs |> nrow()
taylor_album_songs |> ncol()
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Obt√©n los √°lbumes √∫nicos del dataset. ¬øCu√°ntos hay?

```{r}
#| code-fold: true
#| eval: false
taylor_album_songs |> distinct(album_name)
taylor_album_songs |>
  distinct(album_name) |>
  nrow()
```


### [**Ejercicio 3**]{.hl-yellow}

üìù ¬øEn cu√°ntas canciones tuvo colaboraci√≥n con otro artista? 

```{r}
#| code-fold: true
#| eval: false

# n¬∫ canciones con colaboraci√≥n
taylor_album_songs |>
  drop_na(featuring) |>
  nrow()
```

### [**Ejercicio 4**]{.hl-yellow}

üìù ¬øCu√°ntos artistas (√∫nicos) han colaborado con ella?

```{r}
#| code-fold: true
#| eval: false
# n¬∫ de colaboradores √∫nicos
taylor_album_songs |>
  drop_na(featuring) |> 
  summarise(n_collabs = n_distinct(featuring))
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Crea un nuevo `tibble` solo con las variables `album_name`, `album_release`, `track_name`, `featuring` y `duration_ms`. Despu√©s ordena dicho tibble de m√°s reciente a m√°s antiguo

```{r}
#| code-fold: true
#| eval: false
nuevo_tb <-
  taylor_album_songs |>
  select(album_name, album_release, track_name, featuring, duration_ms)
nuevo_tb |> 
  arrange(desc(album_release))
```


### [**Ejercicio 6**]{.hl-yellow}

üìù A√±ade al dataset anterior 2 variables con el mes y a√±o de la variable de fecha `album_release`. Piensa c√≥mo determinar el mes con m√°s canciones

```{r}
#| code-fold: true
#| eval: false
library(lubridate)
nuevo_tb <-
  nuevo_tb |> 
  mutate(month = month(album_release), year = year(album_release)) 
nuevo_tb |> 
  count(month, sort = TRUE)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Obt√©n la duraci√≥n media de las canciones en minutos (variable `duration_ms` en milisegundos). Extrae la info de la canci√≥n que m√°s dura

```{r}
#| code-fold: true
#| eval: false

nuevo_tb |>
  drop_na(duration_ms) |> 
  summarise(avg_dur = mean(duration_ms/60000))

nuevo_tb |> 
  slice_max(duration_ms)
```

:::

--- 

## üê£ Caso pr√°ctico III: starwars {#caso-practico-1-3}

Vamos a usar al dataset `starwars` del paquete `{dplyr}`

```{r}
library(dplyr)
starwars
```

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-iii-starwars-dplyr)


---

## üê£ Caso pr√°ctico IV: aviones {#caso-practico-1-4}


Para los ejercicios usaremos las tablas disponibles en el paquete `{nycflights13}` (echa un vistazo antes)

```{r}
library(nycflights13)
```

* [**airlines**]{.hl-yellow}: nombre de aerol√≠neas (con su abreviatura).
* [**airports**]{.hl-yellow}: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* [**flights**]{.hl-yellow}: datos de vuelos.
* [**planes**]{.hl-yellow}: datos de los aviones.
* [**weather**]{.hl-yellow}: datos meteorol√≥gicos horarios de las estaciones LGA, JFK y EWR.

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-iv-aviones-de-nyc-join)


# Clase 2: [welcome to R again]{.flow} {#clase-2}

[**...**]{style="color:#444442;"}

* [Importar y exportar](#import-export)
* [R base: if-elses, bucles y funciones](#if-else-bucles)
* [Inicio al an√°lisis estad√≠stico](#stats)

---

## Importar/exportar {#import-export}

Hasta ahora s√≥lo hemos utilizado datos ya cargados en paquetes, pero muchas veces [**necesitaremos importar datos externamente**]{.hl-yellow}. Una de las principales [**fortalezas**]{.hl-yellow} de `R` es que podemos importar datos muy f√°cilmente en diferentes formatos:


* [**Formatos nativos de R**]{.hl-yellow}: archivos `.rda`, `.RData` y `.rds`

* [**Rectangular data (datos tabulados)**]{.hl-yellow}: archivos `.csv` y `.tsv`

* [**Datos sin tabular**]{.hl-yellow}: archivos `.txt`.

* [**Datos en excel**]{.hl-yellow}: archivos `.xls` y`.xlsx`.

* [**Datos desde SAS/Stata/SPSS**]{.hl-yellow}: archivos `.sas7bdat`, `.sav` y `.dat`.

* [**Datos desde Google Drive**]{.hl-yellow}

* [**Datos desde API's**]{.hl-yellow}: aemet, catastro, censo, spotify, etc.

---

## Formatos nativos

Los ficheros [**m√°s sencillos**]{.hl-yellow} para importar a `R` (y que suelen ocupar menos espacio en disco) son sus propias [**extensiones nativas**]{.hl-yellow}: ficheros en formatos `.RData`, `.rda` y `.rds`. Para cargar los primeros basta con [**utilizar la funci√≥n**]{.hl-yellow} `load()` proporcion√°ndole la ruta del fichero.

* Archivos `RData`: vamos a importar el archivo `world_bank_pop.RData` que incluye la tabla `world_bank_pop`


```{r}
load("./datos/world_bank_pop.RData")
world_bank_pop
```


---

## Formatos nativos

* Archivos `.rda`: vamos a importar el dataset airquality desde `airquality.rda`

```{r}
load("./datos/airquality.rda")
airquality |> as_tibble()
```

---

## Formatos nativos

Tenga en cuenta que los archivos cargados con `load()` se cargan [**autom√°ticamente en el entorno**]{.hl-yellow} (con el nombre guardado originalmente), y no s√≥lo se pueden cargar conjuntos de datos: `load()` nos permite cargar m√∫ltiples objetos (no s√≥lo datos tabulares).

Los archivos nativos `.rda` y `.RData` son una forma adecuada de guardar el entorno.

```{r}
load(file = "./datos/multiple_objects.rda")
```


---

## Formatos nativos

* Archivos `.rds`: para este tipo debemos utilizar `readRDS()`, y necesitamos incorporar un [**argumento `file`**]{.hl-yellow} con la ruta. En este caso vamos a importar [**datos de c√°ncer de pulm√≥n**]{.hl-purple} del North Central Cancer Treatment Group. Observe que ahora [**los archivos .rds incorporar solo una tabla, no un objeto en general**]{.hl-red}


```{r}
lung_cancer <-
  readRDS(file = "./datos/NCCTG_lung_cancer.rds") |>
  as_tibble()
lung_cancer
```


::: callout-important

## Importante

Las [**rutas**]{.hl-yellow deben ser siempre [**sin espacios, √±, ni acentos**]{.hl-yellow}. 


:::

---

## Datos tabulados: readr

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene varias funciones √∫tiles para [**cargar datos rectangulares (sin formatear pero tabulados)**]{.hl-yellow}.


:::: columns
::: {.column width="50%"}

* `read_csv()`: archivos `.csv` [**variables separadas por comas**]{.hl-purple}
* `read_csv2()`: variables separadas por [**punto y coma**]{.hl-purple}
* `read_tsv()`: variables separadas por [**tabuladores**]{.hl-purple}.
* `read_table()`: variables separadas por [**espacios**]{.hl-purple}.
* `read_delim()`: funci√≥n generar con opci√≥n de [**especificar el delimitador**]{.hl-purple}.


:::

::: {.column width="50%"}

![](img/data-import-readr.png)
:::
::::

Todos ellos necesitan como **argumento la ruta del fichero** m√°s **otros opcionales** (saltar cabecera o no, decimales, etc). Ver m√°s en <https://readr.tidyverse.org/>

---

## Datos tabulados (.csv, .tsv)

La principal ventaja de `{readr}` es que [**automatiza el formato**]{.hl-yellow} para pasar de un fichero plano (sin formato) a un tibble (en filas y columnas, con formato).


. . .

* Archivo `.csv`: con `read_csv()` cargaremos archivos [**separados por comas**]{.hl-purple}, pasando como [**argumento la ruta**]{.hl-yellow} en `file = ...`. Vamos a importar el conjunto de datos `chickens.csv` (sobre pollos de dibujos animados, por qu√© no). Si nos fijamos en la salida nos da el tipo de variables.

```{r}
library(readr)
chickens <- read_csv(file = "./datos/chickens.csv")
chickens
```

---

## Datos tabulados (.csv, .tsv)


El [**formato de la variable**]{.hl-yellow} se har√° normalmente [**autom√°ticamente**]{.hl-yellow} por `read_csv()`, y podemos consultarlo con `spec()`.


```{r}
spec(chickens)
```

---

## Datos tabulados (.csv, .tsv)

Aunque normalmente lo hace bien autom√°ticamente podemos [**especificar el formato expl√≠citamente**]{.hl-yellow} en `col_types = lista()` (en formato lista, con `col_xxx()` para cada tipo de variable, por ejemplo `eggs_laid` se importar√° como car√°cter). 


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_types = list(col_character(), col_character(),
                            col_character(), col_character()))
chickens
```

---

## Datos tabulados (.csv, .tsv)

Incluso podemos indicar que [**variables queremos seleccionar**]{.hl-yellow} (sin ocupar memoria), indic√°ndolo en `col_select = ...` (en formato lista, con `col_select = ...`).


```{r}
chickens <-
  read_csv(file = "./datos/chickens.csv",
           col_select = c(chicken, sex, eggs_laid))
chickens
```

---

## Datos tabulados (.txt)

¬øQu√© ocurre cuando el [**separador no es correcto**]{.hl-red}?


. . .

Si usamos `read_csv()` espera que el separador entre columnas sea una coma pero, como puedes ver con el siguiente `.txt`, lo interpreta todo como una sola columna: [**no tiene coma y no sabe d√≥nde separar**]{.hl-yellow}


```{r}
datos_txt <- read_csv(file = "./datos/massey-rating.txt")
dim(datos_txt)
as_tibble(datos_txt)
```


---

## Datos tabulados (.txt)

Para ello tenemos.

* `read_csv2()` cuando el [**separador es punto y coma**]{.hl-yellow}, `read_tsv()` cuando es un [**tabulador**]{.hl-yellow} y `read_table()` cuando es un  [**espacio**]{.hl-yellow}.

* `read_delim()` en general.

```{r}
datos_txt <- read_table(file = "./datos/massey-rating.txt")
as_tibble(datos_txt)
```


---

## Datos Excel (.xls, .xlsx)

Otro paquete de importaci√≥n clave ser√° el paquete `{readxl}` para [**importar datos desde Excel**]{.hl-yellow}. Tres funciones ser√°n clave:

* `read_xls()` espec√≠fica para `.xls`, `read_xlsx()` espec√≠fica para `.xlsx`.
* `read_excel()`: tanto para `.xls` como para `.xlsx`.


. . .

Vamos a importar `deaths.xlsx` con los registros de defunciones de famosos.

```{r}
library(readxl)
deaths <- read_xlsx(path = "./datos/deaths.xlsx")
deaths
```

---

## Datos Excel (.xls, .xlsx)


```{r}
deaths |> slice(1:6)
```

[**Una desgracia muy com√∫n**]{.hl-red} es que haya alg√∫n tipo de comentario o texto al principio del fichero, teniendo que [**saltar esas filas**]{.hl-yellow}.


---

## Datos Excel (.xls, .xlsx)

Podemos [**saltar estas filas**]{.hl-yellow} directamente en la carga con `skip = ...` (indicando el n√∫mero de filas a saltar).


```{r}
deaths <- read_xlsx(path = "./datos/deaths.xlsx", skip = 4)
deaths
```


---

## Datos Excel (.xls, .xlsx)

Adem√°s con `col_names = ...` ya podemos renombrar las columnas en la importaci√≥n ([**proporcionar nombres supone 1¬™ l√≠nea ya como dato**]{.hl-yellow})


```{r}
#| code-line-numbers: "2-3"
deaths <-
  read_xlsx(path = "./datos/deaths.xlsx", skip = 5,
            col_names = c("nombre", "profesion", "edad", "hijos", "nacimiento", "muerte"))
deaths
```

---

## Datos Excel (.xls, .xlsx)

A veces las  [**fechas de Excel tienen un formato incorrecto**]{.hl-red} (sorpresa): podemos utilizar `convertToDate()` del paquete `{openxlsx}` para convertirlo.



```{r}
library(openxlsx)
deaths$muerte <- convertToDate(deaths$muerte)
deaths
```
   

---

## Datos Excel (.xls, .xlsx)

Tambi√©n podemos [**cargar un Excel con varias hojas**]{.hl-yellow}: para [**indicar la hoja**]{.hl-yellow} (ya sea por su nombre o por su n√∫mero) utilizaremos el argumento `sheet = ...`.


```{r}
mtcars <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "mtcars")
mtcars
```

---

## Datos Excel (.xls, .xlsx)

 
Incluso podemos indicar el [**rango de celdas**]{.hl-yellow} a cargar con `range = ...`.

```{r}
iris <- read_xlsx(path = "./datos/datasets.xlsx", sheet = "iris", range = "C1:E4")
iris
```

---

## Importar desde SAS/STATA/SPSS

El paquete `{haven}` dentro del universo tidyverse nos permitir√° [**importar ficheros de los 3 software de pago m√°s importantes**]{.hl-yellow}: SAS, SPSS y Stata.


```{r}
library(haven)

# SAS
iris_sas <- read_sas(data_file = "./datos/iris.sas7bdat")

# SPSS
iris_spss <- read_sav(file = "./datos/iris.sav")

# Stata
iris_stata <- read_dta(file = "./datos/iris.dta")
```

---


## Exportar

De la misma forma que podemos importar tambi√©n podemos [**exportar**]{.hl-yellow}

* exportar en `.RData` (opci√≥n recomendada para variables almacenadas en `R`). Recuerda que esta extensi√≥n [**s√≥lo se puede utilizar en `R`**]{.hl-yellow}. Para ello, basta con utilizar `save(object, file = path)`.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
save(table, file = "./datos/table.RData")
rm(table) # eliminar
load("./datos/table.RData")
table
```

---

## Exportar

La ventaja de `.RData` es que podemos [**exportar m√∫ltiples variables de nuestro environment**]{.hl-yellow}, no solo un √∫nico dataset.

```{r}
table <- tibble("a" = 1:4, "b" = 1:4)
a <- 1
b <- c("javi", "sandra")
save(table, a, b, file = "./datos/mult_obj.RData")
rm(list = c("a", "b", "table"))
load("./datos/mult_obj.RData")
table
```

---

## Exportar

* [**exportado en `.csv`**]{.hl-yellow}. Para ello simplemente utilizamos `write_csv(object, file = path)`, y es el m√°s recomendable para exportar bases de datos de tama√±o peque√±o o mediano. Ver <https://arrow.apache.org/docs/r/> para bases de datos masivas.

```{r}
write_csv(table, file = "./datos/table.csv")
read_csv(file = "./datos/table.csv")
```

---

## Importar desde web

Una de las principales ventajas de `R` es que podemos hacer uso de todas las funciones anteriores de [**importar pero directamente desde una web**]{.hl-yellow}, sin necesidad de realizar la descarga manual: en lugar de pasarle la ruta local le indicaremos el [**enlace**]{.hl-yellow}. Por ejemplo, vamos a descargar los datos covid del ISCIII (<https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>)

```{r}
#| eval: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
covid_data
```

```{r}
#| echo: false
covid_data <-
  read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv", n_max = 500)
covid_data
```

---

## Importar desde wikipedia

El paquete `{rvest}`, uno de los m√°s √∫tiles de `{tidyverse}` nos permite [**importar (scrappear) directamente desde un `html`**]{.hl-yellow}. Por ejemplo, para exportar tablas de wikipedia basta con `read_html()` para importar el html, `html_element(¬´table¬ª)` para extraer los objetos tabla, y `html_table()` para convertir la tabla html a `tibble`.


```{r}
library(rvest)
wiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'
wiki_jump |> read_html() |> 
  html_element("table") |> 
  html_table()
```

---


## üê£ Caso pr√°ctico I: renta municipios {#caso-practico-2-1}

En el archivo `municipios.csv` tenemos guardada la informaci√≥n de los municipios de Espa√±a a fecha de 2019. La variable `LAU_code` representa el c√≥digo como unidad administrativa local seg√∫n la estandarizaci√≥n de la UE ([ver m√°s](https://ec.europa.eu/eurostat/web/nuts/local-administrative-units)).La variable `codigo_ine` est√° construida uniendo el c√≥digo de la provincia y el de la comunidad aut√≥noma.


Por otro lado el archivo `renta_mun` contiene datos de la renta per capita  de cada unidad administrativa (municipios, distritos, provincias, comunidades auton√≥nomas, etc) para diferentes a√±os.



&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-i-renta-de-municipios)

---


## Bucles {#if-else-bucles}

Aunque en la mayor√≠a de ocasiones se pueden reemplazar por otras estructuras m√°s eficientes y legibles, es importante conocer una de las expresiones de control m√°s famosas: los [**bucles**]{.hl-yellow}.

* `for { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} en un [**n√∫mero prefijado y conocido**]{.hl-purple} de veces.

* `while { }`: permite [**repetir el mismo c√≥digo**]{.hl-yellow} pero en un [**n√∫mero indeterminado de veces**]{.hl-purple} (hasta que una **condici√≥n** deje de cumplirse).

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  
}
```

---

## Bucles for {auto-animate="true"}

Un bucle [**for**]{.hl-yellow} es una estructura que permite [**repetir**]{.hl-yellow} un conjunto de √≥rdenes un n√∫mero [**finito, prefijado y conocido de veces**]{.hl-purple} dado un conjunto de √≠ndices.


Vamos a definir un vector `x <- c(0, -7, 1, 4)` y otra variable vac√≠a `y`. Tras ello definiremos un bucle for con `for () { }`: dentro de los par√©ntesis indicaremos un √≠ndice y unos valores a recorrer, dentro de las llaves el c√≥digo a ejecutar en cada iteraci√≥n (en este caso, rellenar `y` como `x + 1`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
```

---

## Bucles for

F√≠jate que debido a que `R` funciona de manera [**vectorial por defecto**]{.hl-yellow}, el bucle es lo mismo que hacer `x + 1` directamente.

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:4) {
  y[i] <- x[i] + 1
}
y

y2 <- x + 1
y2
```

---

## Bucles for

Otra opci√≥n habitual es indicar los √≠ndices de manera ¬´autom√°tica¬ª: desde el primero `1` hasta el √∫ltimo (que corresponde con la longitud de x `length(x)`)

```{r}
x <- c(0, -7, 1, 4)
y <- c()

for (i in 1:length(x)) {
  y[i] <- x[i] + 1
}
y

```


---

## Bucles for

As√≠ la [**estructura general de un bucle for**]{.hl-yellow} ser√° siempre la siguiente

```{r}
#| eval: false
for (√≠ndice in conjunto) { 
  c√≥digo (dependiente de i)
}
```

[**SIEMPRE**]{.hl-green} sabemos cu√°ntas iteraciones tenemos (tantas como elementos haya en el conjunto a indexar)

---

## Evitando bucles


Como ya hemos aprendido con el paquete`{microbenchmark}` podemos chequear como [**los bucles suelen ser muy ineficientes**]{.hl-yellow} (de ah√≠ que debamos evitarlos en la mayor√≠a de ocasiones

```{r}
library(microbenchmark)
x <- 1:1000
microbenchmark(y <- x^2, 
               for (i in 1:100) { y[i] <- x[i]^2 },
               times = 500)
```

---
 
## Bucles for


Podemos ver otro ejemplo de bucle  [**combinando n√∫meros y textos**]{.hl-yellow}: definimos un vector de edades y de nombres, e imprimimos el nombre y edad i-√©sima.

```{r}
nombres <- c("Javi", "Sandra", "Carlos", "Marcos", "Marta")
edades <- c(33, 27, 18, 43, 29)
library(glue)
for (i in 1:5) { 
  
  print(glue("{nombres[i]} tiene {edades[i]} a√±os")) 
  
}
```


---

## Bucles for

Aunque normalmente se suelen indexar con vectors num√©ricos, los bucles pueden ser [**indexados sobre cualquier estructura vectorial**]{.hl-yellow}, da igual de que tipo sea el conjunto

```{r}
library(stringr)
week_days <- c("monday", "tuesday", "wednesday", "thursday",
               "friday", "saturday", "sunday")

for (days in week_days) {
  
  print(str_to_upper(days))
}
```

---

## Bucles y condicionales

Vamos a **combinar las estructuras condicionales y los bucles**: usando el conjunto `swiss` del paquete `{datasets}`, vamos a asignar `NA`  si los valores de fertilidad son mayores de 80.

```{r}
for (i in 1:nrow(swiss)) {
  
  if (swiss$Fertility[i] > 80) { 
    
    swiss$Fertility[i] <- NA
    
  }
}
```

. . .

Esto es exactamente igual a un `if_else()` vectorizado

```{r}
data("swiss")
swiss$Fertility <- if_else(swiss$Fertility > 80, NA, swiss$Fertility)
```


---

## Bucles while

Otra forma de crear un bucle es con la estructura `while { }`, que nos ejecutar√° un bucle [**un n√∫mero desconocido de veces**]{.hl-yellow}, hasta que una condici√≥n [**deje de cumplirse**]{.hl-yellow} (de hecho puede que nunca termine). Por ejemplo, vamos a inializar una variable `ciclos <- 1`, que incrementaremos en cada paso, y no saldremos del bucle hasta que `ciclos > 4`.

```{r}
ciclos <- 1
while(ciclos <= 4) {
  
  print(glue("No todav√≠a, vamos por el ciclo {ciclos}")) 
  ciclos <- ciclos + 1
  
}
```

---

## Bucles while

Un bucle `while` ser√° siempre como sigue

```{r}
#| eval: false
while(condici√≥n) {
  
  c√≥digo a hacer mientras la condici√≥n sea TRUE
  # normalmente aqu√≠ se actualiza alguna variable
  
}
```

---
  
## Bucles while

¬øQu√© sucede cuando la [**condici√≥n nunca es FALSE**]{.hl-yellow}? Pru√©balo tu mismo

```{r}
#| eval: false
while (1 > 0) {
  
  print("Presiona ESC para salir del bucle")
  
}
```

&nbsp;

::: callout-warning
## Cuidado

Un bucle `while { }` puede ser bastante ¬´peligroso¬ª sino controlamos bien c√≥mo pararlo.

:::

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `break`: permite [**abortar un bucle**]{.hl-yellow} incluso si no se ha llegado a su final

```{r}
for(i in 1:10) {
  if (i == 3) {
    
    break # si i = 3, abortamos bucle
    
  }
  print(i)
}
```

---

## Bucles while

Contamos con dos palabras reservadas para [**abortar un bucle o forzar su avance**]{.hl-yellow}:

* `next`: [**fuerza un bucle a avanzar a la siguiente iteraci√≥n**]{.hl-yellow} 

```{r}
for(i in 1:5) {
  if (i == 3) {
    
    next # si i = 3, la obvia y continua al siguiente
    
  }
  print(i)
}
```


---


## üíª Tu turno {#tu-turno-2-1}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}


::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para que se imprima un mensaje por pantalla si y solo si todos los datos de `airquality` son con mes distinto a enero

```{r}
#| eval: false
library(datasets)
months <- airquality$Month

if (months == 2) {
  print("No hay datos de enero")
}
```

```{r}
#| code-fold: true
#| eval: false
library(datasets)
months <- airquality$Month

if (all(months != 1)) {
  print("No hay datos de enero")
}
```


### [**Ejercicio 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para guardar en una variable llamada `temp_alta` un `TRUE` si alguno de los registros tiene una temperatura superior a 90 grados Farenheit y `FALSE` en cualquier otro caso
 
```{r}
#| eval: false
temp <- airquality$Temp

if (temp == 100) {
  print("Algunos de los registros tienen temperaturas superiores a 90 grados Farenheit")
}
```

 
```{r}
#| eval: false
#| code-fold: true
# Option 1
temp <- airquality$Temp
temp_alta <- FALSE
if (any(temp > 90)) {
   temp_alta <- TRUE
}

# Option 2
temp_alta <- any(airquality$Temp > 90)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `for` de 5 iteraciones que solo recorra los primeros 5 impares (y en cada paso del bucle los imprima)

```{r}
#| eval: false
for (i in 1:5) {
  
  print(i)
}
```

```{r}
#| eval: false
#| code-fold: true
for (i in c(1, 3, 5, 7, 9)) {
  
  print(i)
}
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para dise√±ar un bucle `while` que empiece con un contador `count <- 1` y pare cuando llegue a 6

```{r}
#| eval: false
count <- 1
while (count == 2) {
  
  print(count)
}
```

```{r}
#| eval: false
#| code-fold: true
count <- 1
while (count < 6) {
  
  print(count)
  count <- count + 1
  
}
```


:::

---


---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.



```{r}
#| eval: false
name_fun <- function() {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
}
```

---

## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
}
```

---


## Creando funciones {auto-animate="true"}

No solo podemos usar **funciones predeterminadas** que vienen ya cargadas en paquetes, adem√°s podemos [**crear nuestras propias funciones**]{.hl-yellow} para **automatizar tareas**. ¬øC√≥mo [**crear nuestra propia funci√≥n**]{.hl-purple}? Veamos su **esquema b√°sico**:

* [**Nombre**]{.hl-yellow}: por ejemplo `name_fun` (sin espacios ni caracteres extra√±os). Al nombre le [**asignamos la palabra reservada**]{.hl-yellow} `function()`.

* Definir [**argumentos de entrada**]{.hl-yellow} (dentro de `function()`).

* [**Cuerpo**]{.hl-yellow} de la funci√≥n dentro de `{ }`.

* Finalizamos la funci√≥n con los [**argumentos de salida**]{.hl-yellow} con `return()`.

```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  c√≥digo a ejecutar
  
  return(var_salida)
  
}
```


---

## Creando funciones

* `arg1, arg2, ...`: ser√°n los [**argumentos de entrada**]{.hl-yellow}, los argumentos que toma la funci√≥n para ejecutar el c√≥digo que tiene dentro

* `c√≥digo`: l√≠neas de c√≥digo que queramos que [**ejecute la funci√≥n**]{.hl-yellow}. 

* `return(var_salida)`: se introducir√°n los [**argumentos de salida**]{.hl-yellow}.


```{r}
#| eval: false
name_fun <- function(arg1, arg2, ...) {
  
  # C√≥digo que queramos ejecutar
  c√≥digo
  
  # Salida
  return(var_salida)
  
}
```

::: callout-important
## Importante

Todas las variables que definamos dentro de la funci√≥n son [**variables LOCALES: solo existir√°n dentro de la funci√≥n**]{.hl-yellow} salvo que especifiquemos lo contrario.

:::

---

## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  
}
```

---


## Creando funciones {auto-animate="true"}

Veamos un ejemplo muy simple de funci√≥n para [**calcular el √°rea de un rect√°ngulo**]{.hl-yellow}.

Dado que el √°rea de un rect√°ngulo se calcula como el **producto de sus lados**, necesitaremos precisamente eso, sus lados: esos ser√°n los [**argumentos de entrada**]{.hl-yellow} y el [**valor a devolver**]{.hl-purple} ser√° justo su **√°rea** ($lado_1 * lado_2$).

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  area <- lado_1 * lado_2
  return(area)
  
}
```

---

## Uso de funciones

Tambi√©n podemos hacer una definici√≥n directa de las variables **sin almacenar por el camino**.

```{r}
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2) {
  
  return(lado_1 * lado_2)
  
}
```

. . .

[**¬øC√≥mo aplicar la funci√≥n?**]{.hl-yellow}

```{r}
calcular_area(5, 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(1, 5) # √°rea de un rect√°ngulo 1 x 5
```

---

## Uso de funciones

::: callout-tip

Aunque no sea necesario, es [**recomendable hacer expl√≠cita la llamada de los argumentos**]{.hl-green}, especificando en el c√≥digo qu√© valor es para cada argumento para que no dependa de su orden, haciendo el c√≥digo m√°s legible
:::


```{r}
calcular_area(lado_1 = 5, lado_2 = 3) # √°rea de un rect√°ngulo 5 x 3 
calcular_area(lado_2 = 3, lado_1 = 5) # √°rea de un rect√°ngulo 5 x 3 
```

---

## Argumentos por defecto

Imagina ahora que nos damos cuenta que el 90% de las veces usamos dicha funci√≥n para [**calcular por defecto el √°rea de un cuadrado**]{.hl-yellow} (es decir, solo necesitamos un lado). Para ello, podemos definir [**argumentos por defecto**]{.hl-yellow} en la funci√≥n: tomar√°n dicho valor salvo que le asignemos otro.

¬øPor qu√© no asignar `lado_2 = lado_1` **por defecto**, para ahorrar l√≠neas de c√≥digo y tiempo?

. . .

```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

---

## Argumentos por defecto


```{r}
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```


Ahora [**por defecto**]{.hl-yellow} el segundo lado ser√° igual al primero (si se lo a√±adimos usar√° ambos).


```{r}
calcular_area(lado_1 = 5) # cuadrado
calcular_area(lado_1 = 5, lado_2 = 7) # rect√°ngulo
```

---
 

## Salida m√∫ltiple

Compliquemos un poco la funci√≥n y a√±adamos en la salida los valores de cada lado, etiquetados como `lado_1` y `lado_2`, [**empaquetando la salida en una vector**]{.hl-yellow}.

```{r}
#| code-line-numbers: "7-8"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
  
}
```

---

## Salida m√∫ltiple

Podemos complicar un poco m√°s la salida a√±adiendo una cuarta variable que nos diga, en funci√≥n de los argumentos, [**si rect√°ngulo o cuadrado**]{.hl-yellow}, teniendo que a√±adir en la salida una variable que de tipo caracter (o l√≥gica).

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

. . .

[**Problema**]{.hl-red}: al intentar juntar n√∫meros y texto, lo convierte todo a n√∫meros. Podr√≠amos guardarlo todo en un `tibble()` como hemos aprendido o en un objeto conocido en `R` como [**listas**]{.hl-yellow}

---

## Introducci√≥n a listas

Veamos un peque√±o resumen de los datos que ya conocemos:

* [**vectores**]{.hl-yellow}: colecci√≥n de elementos de igual tipo. Pueden ser n√∫meros, caracteres o valores l√≥gicos, entre otros.

* [**matrices**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual tipo e igual longitud.

* [**data.frame / tibble**]{.hl-yellow}: colecci√≥n BIDIMENSIONAL de elementos de igual longitud pero de cualquier tipo.

. . .

Las [**listas**]{.hl-yellow} ser√°n [**colecciones de variables de diferente tipo y diferente longitud**]{.hl-purple}, con estructuras totalmente heter√≥geneas (incluso una lista puede tener dentro a su vez otra lista).

---

## Introducci√≥n a listas


Vamos a crear [**nuestra primera lista**]{.hl-yellow} con `list()` con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
var_1 <- c("Paloma", "Gregorio")
var_2 <- "Madrid"
var_3 <- c(25, 30, 26)

lista <- list("progenitores" = var_1, "lugar_nac" = var_2, "edad_hermanos" = var_3)
lista
```



---

## Introducci√≥n a listas

```{r}
length(lista)
```

Si observas el objeto que hemos definido como lista, su [**longitud**]{.hl-yellow} del es de 3 ya que tenemos **guardados tres elementos**: un vector de caracteres (de longitud 2), un caracter (vector de longitud 1), y un vector de n√∫meros (de longitud 3)

. . .

Tenemos guardados elementos de [**distinto tipo**]{.hl-yellow} (algo que ya pod√≠amos hacer) pero, adem√°s, de **longitudes dispares**.

```{r}
dim(lista) # devolver√° NULL al no tener dos dimensiones
class(lista) # de tipo lista
```

---

## Introducci√≥n a listas

Si los junt√°semos con un `tibble()`, al tener distinta longitud, obtendr√≠amos un [**error**]{.hl-red}.

```{r}
#| error: true
library(tibble)
tibble("progenitores" = var_1, "lugar_nac" = va_2, "edad_hermanos" = var_3)
```

---


## Introducci√≥n a listas

* [**Acceder por √≠ndice**]{.hl-yellow}: con el operador `[[i]]` accedemos al **elemento i-√©simo** de la lista.

```{r}
lista[[1]]
```

. . .

* [**Acceder por nombre**]{.hl-yellow}: con `$nombre_elemento` accedemos por su nombre.

```{r}
lista$progenitores
```

. . .

En contraposici√≥n, el [**corchete simple**]{.hl-yellow} nos permite acceder a [**varios elementos**]{.hl-yellow} a la vez

```{r}
# Varios elementos
lista[1:2]
```

---

## Salida m√∫ltiple: listas

```{r}
#| code-line-numbers: "7-9"
# Definici√≥n del nombre de funci√≥n y argumentos de entrada
calcular_area <- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la funci√≥n
  area <- lado_1 * lado_2
  
  # Resultado
  return(list("area" = area, "lado_1" = lado_1, "lado_2" = lado_2,
           "tipo" = if_else(lado_1 == lado_2, "cuadrado", "rect√°ngulo")))
  
}
calcular_area(5, 3)
```

---

## Orden de los argumentos

Antes nos daba igual el orden de los argumentos pero ahora el [**orden de los argumentos de entrada importa**]{.hl-yellow}, ya que en la salida incluimos `lado_1` y `lado_2`. 

. . .

::: callout-note
## Recomendaci√≥n

Como se comentaba, altamente recomendable hacer la llamada a la funci√≥n [**indicando expl√≠citamente los argumentos**]{.hl-yellow} para mejorar **legibilidad e interpretabilidad**.

```{r}
# Equivalente a calcular_area(5, 3)
calcular_area(lado_1 = 5, lado_2 = 3)
```

:::

---

## Funciones: generando conocimiento

Parece una tonter√≠a lo que hemos hecho pero hemos cruzado una frontera importante: hemos pasado de [**consumir conocimiento**]{.hl-yellow} (c√≥digo de otros paquetes, elaborado por otros/as), a [**generar conocimiento**]{.hl-purple}, creando nuestras propias funciones.

. . .

Las funciones van a ser claves en tu d√≠a a d√≠a ya que te permitir√° automatizar c√≥digo que vas a repetir una y otra vez: empaquetando ese c√≥digo bajo un alias (nombre de la funci√≥n) vas a [**poder usarlo una y otra vez sin necesidad de programarlo (por lo que hacer el doble de trabajo no implicar√° trabajar el doble)**]{.hl-yellow}

---

## Variables locales vs globales

Un aspecto importante sobre el que reflexionar con las funciones: ¬øqu√© sucede si [**nombramos a una variable dentro**]{.hl-yellow} de una funci√≥n a la que se nos ha **olvidado asignar** un valor dentro de la misma?

. . .

Debemos ser cautos al usar funciones en `R`, ya que debido a la [**¬´regla lexicogr√°fica¬ª**]{.hl-yellow}, si una variable no se define dentro de la funci√≥n, `R` [**buscar√° dicha variable en el entorno**]{.hl-purple} de variables.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  print(x) # No devuelve nada, solo realiza la acci√≥n 
}
funcion_ejemplo()
```

---

## Variables locales vs globales

Si una variable  [**ya est√° definida fuera de la funci√≥n (entorno global)**]{.hl-yellow}, y adem√°s es usada dentro de cambiando su valor, el valor [**solo cambia dentro**]{.hl-yellow} pero [**no en el entorno global**]{.hl-red}.

```{r}
x <- 1
funcion_ejemplo <- function() {
    
  x <- 2
  print(x) # lo que vale dentro
}
```

```{r}
# lo que vale dentro
funcion_ejemplo() #<<
# lo que vale fuera
print(x) #<<
```

---

## Variables locales vs globales


Si queremos que adem√°s de cambiar localmente lo haga [**globalmente**]{.hl-yellow} deberemos usar la [**doble asignaci√≥n**]{.hl-yellow} (`<<-`).

```{r}
x <- 1
y <- 2
funcion_ejemplo <- function() {
  
  # no cambia globalmente, solo localmente
  x <- 3 
  # cambia globalmente
  y <<- 0 #<<
  
  print(x)
  print(y)
}

funcion_ejemplo() # lo que vale dentro
x # lo que vale fuera
y # lo que vale fuera
```

---


## üíª Tu turno {#tu-turno-2-2}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ej 1**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.

```{r}
#| eval: false
nombre <- function(x, y) {
  suma <- # c√≥digo a ejecutar
  return()
}
# Aplicamos la funci√≥n
suma(3, 7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_suma <- function(x, y) {
  suma <- x + y
  return(suma)
}
funcion_suma(3, 7)
```

### [**Ej 2**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir una funci√≥n llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto, pero que por defecto calcule el cuadrado

```{r}
#| eval: false
nombre <- function(x, y) {
  producto <- # c√≥digo de la multiplicaci√≥n
  return()
}
producto(3)
producto(3, -7)
```

```{r}
#| code-fold: true
#| eval: false
funcion_producto <- function(x, y = x) {
  producto <- x * y
  return(producto)
}
funcion_producto(3)
funcion_producto(3, -7)
```

### [**Ej 3**]{.hl-yellow}

üìù Define una funci√≥n llamada `igualdad_nombres` que, dados dos nombres, nos diga si son iguales o no. Hazlo considerando importantes las may√∫sculas, y sin que importen las may√∫sculas. Usa el paquete `{stringr}`.

```{r}
#| code-fold: true
#| eval: false
# Distinguiendo may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")

# Sin importar may√∫sculas
igualdad_nombres <- function(persona_1, persona_2) {
  return(str_to_upper(persona_1) == str_to_upper(persona_2))
  # otra opci√≥n
  # return(str_equal(persona_1, persona_2, ignore_case = TRUE))
}
igualdad_nombres("Javi", "javi")
igualdad_nombres("Javi", "Luc√≠a")
```

### [**Ej 4**]{.hl-yellow}

üìù Crea una funci√≥n llamada `calculo_IMC` que, dados dos argumentos (peso y estatura en metros) y un nombre, devuelva una lista con el IMC ($peso/(estatura_m^2)$) y el nombre.

```{r}
#| code-fold: true
#| eval: false
calculo_IMC <- function(nombre, peso, estatura) {
  
  return(list("nombre" = nombre, "IMC" = peso/(estatura^2)))
}
```

:::


## üê£ Caso pr√°ctico II: simulaci√≥n {#caso-practico-2-2}


Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-ii-simulaci%C3%B3n) donde tendr√°s que dise√±ar algunos estudios de simulaci√≥n haciendo uso de **bucles, estructuras condicionales y funciones**

---

## Intro a la estad√≠stica en R {#stats}


La estad√≠stica descriptiva es una rama de la estad√≠stica que se dedica a [**recolectar, organizar, presentar y analizar un conjunto de datos**]{.hl-yellow} para describir las caracter√≠sticas y comportamientos de dicho conjunto.

&nbsp;

Adem√°s de para conocer y entender los datos es la fase en la que [**detectaremos errores e incongruencias**]{.hl-yellow}, teniendo muchas veces que hacer una [**depuraci√≥n de datos**]{.hl-yellow}

---

## Recolecci√≥n

La podemos hacer a trav√©s de **encuestas, experimentos, observaciones, registros**, etc. Lo m√°s importante en esta etapa es que los datos sean representativos del fen√≥meno o poblaci√≥n que se estudia. La rama de la estad√≠stica que se dedica a estudiar esta parte del an√°lisis se conoce como [**muestreo**]{.hl-yellow}, y es fundamental para evitar sesgos en la muestra.


![](https://sketchplanations.com/_next/image?url=https%3A%2F%2Fimages.prismic.io%2Fsketchplanations%2Ff2fdb7cb-f126-4897-ad78-4fd11c743172_SP%2B723%2B-%2BSampling%2Bbias.png%3Fauto%3Dcompress%2Cformat&w=828&q=75)

---

## Conceptos b√°sicos

En estad√≠stica es fundamental entender los conceptos de [**poblaci√≥n, muestra y variable**]{.hl-yellow}, ya que son la base para cualquier an√°lisis estad√≠stico.

. . .

-   [**Poblaci√≥n**]{.hl-yellow}

La poblaci√≥n es el **conjunto completo de elementos o individuos** sobre los cuales se desea obtener informaci√≥n. En la mayor√≠a de casos el acceso a la **totalidad de la poblaci√≥n es inviable** por motivos econ√≥micos, legales o √©ticos, as√≠ que en la mayor√≠a de situaciones las conclusiones deberemos sacarlas haciendo uso de una **muestra**.

. . .

**Ejemplo**: la diferencia entre censo y encuesta es que el primero recopila datos de todos los individuos de una poblaci√≥n, mientras que el segundo trata de estimarlos o inferirlos a partir de una muestra representativa de la misma.

---

## Conceptos b√°sicos

[**Muestra**]{.hl-yellow}: subconjunto de la poblaci√≥n que se selecciona para su an√°lisis con el fin de hacer inferencias o generalizaciones sobre la poblaci√≥n completa. La muestra debe ser **representativa de la poblaci√≥n**.

-   **Muestreo aleatorio simple**: cada miembro de la poblaci√≥n tiene la misma probabilidad de ser seleccionado.

-   **Muestreo estratificado**: la poblaci√≥n se divide en subgrupos (estratos) y se toma una muestra de cada uno.

-   **Muestreo (no aleatorio) sistem√°tico**: se selecciona cada n-√©simo miembro de la poblaci√≥n.

-   **Muestreo (no aleatorio) por cuotas**: se seleccionan aquellos individuos que cumplan ciertas condiciones.

-   **Muestreo por conveniencia**: se elige a los miembros que son m√°s f√°ciles de acceder, aunque este m√©todo puede introducir sesgos.

---


## Conceptos b√°sicos

[**Variable**]{.hl-yellow}: **cualquier caracter√≠stica o atributo** que puede tomar diferentes valores entre los individuos de la poblaci√≥n o muestra. Las variables pueden ser de varios tipos seg√∫n su naturaleza:

-   [**Cualitativas (o categ√≥ricas)**]{.hl-purple}: describen cualidades o categor√≠as. Ejemplos:

    -   Nominales: no tienen un orden intr√≠nseco (e.g., g√©nero, estado civil, religi√≥n, etc).
    -   Ordinales: tienen un orden intr√≠nseco (e.g., niveles de satisfacci√≥n, grado acad√©mico, sano-leve-grave, tramo etario, tramo de ingresos, etc).

---

## Conceptos b√°sicos

[**Variable**]{.hl-yellow}: **cualquier caracter√≠stica o atributo** que puede tomar diferentes valores entre los individuos de la poblaci√≥n o muestra. Las variables pueden ser de varios tipos seg√∫n su naturaleza:

-   [**Cuantitativas**]{.hl-purple}: describen cantidades y pueden ser medidas num√©ricamente. Ejemplos:

    -   Discretas finitas: toman valores finitos (e.g., n√∫mero de hijos, n√∫mero de visitas al m√©dico, escala de dolor).
    -   Discretas infinitas: toman valores infinitos (o que se podr√≠an considerar como tal) pero podemos enumerarlas y sabemos siempre el siguiente elemento (e.g., n√∫mero de pelos de nuestra cabellera, n√∫mero de personas que pueden entrar en una tienda en un periodo dado).
    -   Continuas: pueden tomar cualquier valor dentro de un rango (e.g., altura, peso, tiempo de espera).

---

## Conceptos b√°sicos

[**Modalidades**]{.hl-yellow}: uno de los **posibles valores** que toma una **variable dentro de una muestra**. El **conjunto de modalidades posibles** que podr√≠a haber tomado (en tu poblaci√≥n) se suele conocer tambi√©n como soporte. Algunos ejemplos en funci√≥n del tipo de variables son:

-  **Cualitativa nominal (color de ojos)**: negro, azul y marr√≥n (3 modalidades en esa muestra de un espectro de colores m√°s amplio que podr√≠amos tener como soporte).

- **Cualitativa ordinal (estado del paciente)**: sano, leve y grave (3 modalidades en esa muestra de un conjunto de opciones - por ejemplo, sano, leve, grave, UCI, fallecido - que podr√≠amos tener).


---

## Caracter√≠sticas num√©ricas

Nos referimos a las medidas con las que se pretende resumir y condensar la informaci√≥n contenida en un conjunto de datos. Las mayor√≠a de caracter√≠sticas num√©ricas las mediremos en variables cuantitativas.

-   [**Medidas de centralizaci√≥n y posici√≥n**]{.hl-yellow}

Son los valores que resumen el conjunto de los datos de forma que reflejan el **centro de la distribuci√≥n** de la tabla de frecuencias

---

## Media

Es el [**valor medio o centro de gravedad**]{.hl-yellow} (el valor m√°s cercano a todos los puntos "a la vez"). Es la suma de todos los valores dividida por el n√∫mero total de valores.

$$\bar x= \frac{\sum^n_{i=1} x_i}{n}$$


::: callout-warning
## Cuidado...

La media es una medida √∫til y ampliamente aplicada de la tendencia central, pero debe ser utilizada **con precauci√≥n** en conjuntos de datos que contienen valores at√≠picos o est√°n distribuidos de manera asim√©trica.
:::

---

## Mediana

Es el [**valor del medio SIEMPRE Y CUANDO podamos ordenar**]{.hl-yellow} los datos. Divide la distribuci√≥n de frecuencias en dos partes.

Para calcularla debemos realizar los siguientes pasos:

1.  Ordenar los datos en orden creciente

2.  Seg√∫n el n√∫mero de observaciones (n):

    -   Si n es impar: la mediana es el valor que ocupa la posici√≥n central
    -   Si n es par: la mediana es el promedio de los dos valores central


::: callout-tip
## Consejo

La mediana es especialmente √∫til en **distribuciones asim√©tricas** o cuando se quiere una medida de tendencia central que no sea afectada por valores extremadamente altos o bajos.
:::

---

## Moda

Es el valor que [**presenta la m√°xima frecuencia**]{.hl-yellow} y se puede calcular para **todas las variables (tambi√©n cualitativas)**.

1.  Unimodal:

    -   Datos: "negro", "negro", "amarillo", "verde", "amarillo", "negro". Moda: "negro".

2.  Bimodal:

    -   Datos: 1, 2, 3, 3, 4, 4, 5. Modas: 3 y 4 (ambos aparecen dos veces)

3.  Multimodal:

    -   Datos: 2, 2, 3, 3, 4, 4, 5, 5. Modas: 2, 3, 4, y 5 (todos aparecen dos veces)

4.  Sin moda (amodal):

    -   Datos: 1, 2, 3, 4, 5
    -   Moda: no hay moda (todos los valores aparecen solo una vez)

---

## Centralidad en R

¬øC√≥mo calcular estas medidas de centralidad en `R`? Vamos a practicar con `starwars` y su variable `mass`


```{r}
#| code-fold: true
library(ggplot2)
ggplot(starwars) +
  geom_histogram(aes(x = mass), bins = 30) +
  theme_minimal()
```

---

## Centralidad en R


```{r}
starwars |> 
  drop_na(mass) |> 
  summarise("media" = mean(mass), "mediana" = median(mass))
```

. . .

¬øPor qu√© hay [**tanta diferencia entre media y mediana**]{.hl-yellow}?

. . .

Si te fijas en el histograma anterior, tenemos un dato extremadamente at√≠pico: la [**distribuci√≥n es extremadamente asim√©trica**]{.hl-red}

---

## Centralidad en R

La moda de variables continuas es mucho m√°s dif√≠cil de cuantificar num√©ricamente y no suele ser √∫til a posteriori pero se puede estimar f√°cilmente como el/los **m√°ximos de la funci√≥n de densidad**.

```{r}
ggplot(starwars) +
  geom_density(aes(x = mass)) +
  theme_minimal()
```

---

## Centralidad en R

En [**variables cualitativas**]{.hl-yellow} la [**media no se puede calcular**]{.hl-red} pero s√≠ la [**mediana (siempre que sean ordinales, es decir, factores ordenados)**]{.hl-green}, as√≠ como la moda.

```{r}
starwars |> 
  count(eye_color, sort = TRUE)
```


---

## Medidas de posici√≥n: cuantiles

Los [**cuantiles son valores que dividen un conjunto de datos en partes iguales**]{.hl-yellow} seg√∫n su distribuci√≥n (de nuevo asumiento que tenemos los datos ordenados de menor a mayor). Los cuantiles son √∫tiles para comprender la distribuci√≥n y la dispersi√≥n de los datos. Existen diferentes tipos de cuantiles, cada uno con un n√∫mero espec√≠fico de divisiones:

1.  **Cuartiles**: dividen el conjunto de datos en cuatro partes iguales.

2.  **Deciles**: dividen el conjunto de datos en diez partes iguales.

3.  **Percentiles**: dividen el conjunto de datos en cien partes iguales.



---

## Cuantiles

1.  [**Cuartiles**]{.hl-yellow}: dividen el conjunto de datos en cuatro partes iguales.

    -   Primer cuartil (Q1): divide el 25% inferior de los datos del 75% superior.
    -   Mediana (Q2): divide el 50% inferior del 50% superior. Es el segundo cuartil.
    -   Tercer cuartil (Q3): divide el 75% inferior del 25% superior.


```{r}
starwars |> 
  drop_na(mass) |> 
  reframe("cuartiles" = quantile(mass))
```

---

## Cuantiles

2.  [**Deciles**]{.hl-yellow}: dividen el conjunto de datos en diez partes iguales.

    -   Primer decil (D1): divide el 10% inferior del 90% superior.
    -   Segundo decil (D2): divide el 20% inferior del 80% superior.
    -   Y as√≠ sucesivamente hasta el noveno decil (D9), que divide el 90% inferior del 10% superior.

```{r}
starwars |> 
  drop_na(mass) |> 
  reframe("cuartiles" =
            quantile(mass, probs = seq(0, 1, by = 0.1)))
```

---

## Cuantiles

3.  [**Percentiles**]{.hl-yellow}: dividen el conjunto de datos en cien partes iguales.

    -   Percentil 1 (P1): divide el 1% inferior del 99% superior.
    -   Percentil 2 (P2): divide el 2% inferior del 98% superior.
    -   Y as√≠ sucesivamente hasta el percentil 99 (P99), que divide el 99% inferior del 1% superior.

```{r}
starwars |> 
  drop_na(mass) |> 
  reframe("cuartiles" =
            quantile(mass, probs = seq(0, 1, by = 0.01)))
```

---

## Percentiles

En `{dplyr}` disponemos de una funci√≥n tremendamente √∫til para [**calcular percentiles**]{.hl-yellow} de una variable: con `percent_rank(variable)` nos construye el percentil (entre 0 y 1 y con un decimal). Por ejemplo, si devuelve $0.414$, corresponde al percentil $44.1\%$

```{r}
starwars |> 
  drop_na(mass) |> 
  mutate("rank" = percent_rank(mass), .before = everything())
```



---

## Medidas de dispersi√≥n

Medidas (solo disponibles para cuantitativas) que nos indican [**c√≥mo de lejos o cerca est√°n las observaciones del valor central**]{.hl-yellow} que hemos calculado

* [**Recorrido o rango**]{.hl-yellow}: diferencia entre el valor m√°ximo y el valor m√≠nimo en un conjunto de datos.


```{r}
starwars |> 
  drop_na(mass) |> 
  summarise("rango" = max(mass) - min(mass))
```

---


## Medidas de dispersi√≥n

Medidas (solo disponibles para cuantitativas) que nos indican [**c√≥mo de lejos o cerca est√°n las observaciones del valor central**]{.hl-yellow} que hemos calculado

* [**Rango intercuart√≠lico (IQR)**]{.hl-yellow}: mide la **amplitud del 50% central de un conjunto de datos ordenados**. Se calcula como la diferencia entre el tercer cuartil (Q3) y el primer cuartil (Q1)

$$IQR = Q_3 - Q_1$$

```{r}
starwars |> 
  drop_na(mass) |> 
  summarise("IQR" =
              diff(as.numeric(quantile(mass, prob = c(0.25, 0.75)))))
```

---

## Medidas de dispersi√≥n

Medidas (solo disponibles para cuantitativas) que nos indican [**c√≥mo de lejos o cerca est√°n las observaciones del valor central**]{.hl-yellow} que hemos calculado

* [**Varianza**]{.hl-yellow}: cuantifica [**cu√°nto var√≠an los datos respecto a la media**]{.hl-yellow} del conjunto calculando las desviaciones al cuadrado respecto a la misma (de hecho la media es la medida de centralidad que nos da una desviaci√≥n al cuadrado m√°s peque√±a en promedio)

$$s^2 = \frac{\sum_{i=1}^n (x_i - \bar x)^2}{n-1}$$

```{r}
starwars |> 
  drop_na(mass) |> 
  summarise("var" = var(mass))
```


---

## Medidas de dispersi√≥n

Medidas (solo disponibles para cuantitativas) que nos indican [**c√≥mo de lejos o cerca est√°n las observaciones del valor central**]{.hl-yellow} que hemos calculado

* [**Desviaci√≥n t√≠pica o est√°ndar**]{.hl-yellow}: ra√≠z cuadrada de la varianza. La [**desviaci√≥n est√°ndar**]{.hl-yellow} se interpreta en las mismas unidades que los datos originales. 

$$s = \sqrt {s^2} = \sqrt {\frac{\sum_{i=1}^n (x_i - \bar x)^2}{n-1}}$$

```{r}
starwars |> 
  drop_na(mass) |> 
  summarise("var" = var(mass), "sd" = sd(mass))
```



---

## Medidas de dispersi√≥n

* [**Coef de variaci√≥n**]{.hl-yellow}: uno de los problemas al **comparar dispersiones** de dos variables diferentes es que tanto la varianza como la desviaci√≥n t√≠pica [**dependen de la escala de los datos**]{.hl-red}. Para poder comparar dispersiones de variables de diferentes rangos (o incluso unidades) existe el conocido como coeficiente de variaci√≥n (CV), siempre adimensional y positivo:

$$CV = \frac s {|\bar x|}$$


```{r}
starwars |> 
  drop_na(mass, height, birth_year) |> 
  summarise("var_mass" = var(mass), "sd_mass" = sd(mass),
            "var_height" = var(height), "sd_height" = sd(height),
            "var_age" = var(birth_year), "sd_age" = sd(birth_year),
            "CV_mass" = sd_mass / abs(mean(mass)),
            "CV_height" = sd_height / abs(mean(height)),
            "CV_age" = sd_age / abs(mean(birth_year)))
```


---

## Tablas de frecuencias

Las variables cualitativas o cuantis discretas las podemos  [**resumir en tablas de frecuencias**]{.hl-yellow} donde se ordenan y estructuran los valores de una variable de forma resumida

-   **Frecuencia absoluta de x**: n¬∫ de veces que se repite cada modalidad de x.

```{r}
starwars |> 
  drop_na(sex) |> 
  count(sex, sort = TRUE)
```

. . .

Si te fijas la [**frecuencia absoluta viene siempre como $n$**]{.hl-yellow} al usar `count()` pero podemos **renombrarla**

```{r}
starwars |> 
  drop_na(sex) |> 
  count(sex, sort = TRUE) |> 
  rename(frec_abs = n)
```


---

## Tablas de frecuencias


A esa tabla de frecuencias podemos a√±adirle la [**frecuencia relativa**]{.hl-yellow} calculada como cada frecuencia absoluta dividida por el total (la suma de todos)


```{r}
starwars |> 
  count(sex, sort = TRUE) |> 
  mutate("frec_rel" = n/sum(n))
```

---


## Tablas de frecuencias

Este proceso podemos obtenerlo de forma [**m√°s sencilla con `R base`**]{.hl-yellow} (recuerda: funciones aplican a vectores aislados, que debes sacar de la tabla con `$` y sin tuber√≠as) con la funci√≥n `table()`

```{r}
tabla_freq <- table(starwars$sex)
tabla_freq
```

---

## Tablas de frecuencias

Tambi√©n podemos obtener en `R base` las [**frecuencias realtivas**]{.hl-yellow} aplicando `prop.table()` a la tabla de frecuencias anterior.

```{r}
prop.table(tabla_freq)
```

. . .

[**Moraleja**]{.hl-green}: no te cases de manera ac√©rrima con una forma de hacer las cosas, ambos mundos van a ser necesarios.

---

## Tablas de frecuencias

Vamos a repetir el ejercicio con el dataset `accidentes_tb` sobre los accidentes de tr√°fico en Madrid fij√°ndonos en la variable `estado_meteorol√≥gico`

```{r}
accidentes_tb |>
  count(estado_meteorol√≥gico, sort = TRUE) |> 
  mutate("frec_abs" = n/sum(n))
```

. . .

¬øQu√© [**diferencias hay respecto a `sex`**]{.hl-yellow}?

---

## Tablas de frecuencias

Si te fijas `estado_meteorol√≥gico` no solo es cualitativa sino [**cualitativa ORDINAL**}{.hl-yellow}: admite una jerarqu√≠a (por ejemplo: NA < Despejado < Nublado < Lluvia d√©bil < Lluvia intensa < Nevando)

```{r}
accidentes_tb |>
  count(estado_meteorol√≥gico, sort = TRUE)
```

. . .

La forma que tenemos en `R` de indicarle que una variable de tipo texto (universo inform√°tico) es una cualitativa y de qu√© tipo (universo estad√≠stica) es haciendo uso de lo que se conoce como [**factores**]{.hl-yellow}


---


## Par√©ntesis: factores

En `R` las [**variables cualitativas pueden ser tratadas como tales**]{.hl-yellow} convirtiendo una cadena de texto a lo que se conoce como [**factor**]{.hl-yellow}. Por ejemplo, supongamos que tenemos un vector de notas

```{r}
notas <- c("suspenso", "notable", "suspenso", "aprobado", "notable", "suspenso")
notas
```

. . .

Para [**convertir a factor nos basta con `factor()`**]{.hl-yellow}. ¬øQu√© notas diferente?

```{r}
notas_fct <- factor(notas)
notas_fct
```

---


## Par√©ntesis: factores

```{r}
notas_fct
```

Si te fijas ahora [**tenemos disponibles unos niveles (levels)**]{.hl-yellow}: son las posibles modalidades de nuestra variable cualitativa, el soporte, de manera que aunque borremos uno de ellos (vamos a borrar todos los aprobados), la opci√≥n sigue disponible si entrase un dato nuevo (algo as√≠ como un men√∫ de opciones permitidas)

```{r}
notas_fct[notas_fct != "aprobado"]
```

---

## Par√©ntesis: factores

En el caso de las [**cualitativas ordinales podemos incluso establecer una jerarqu√≠a**]{.hl-yellow}, indicando expl√≠citamente los niveles y `ordered = TRUE`

```{r}
notas_fct_ord <- factor(notas, levels = c("aprobado", "notable", "suspenso"),
                        ordered = TRUE)
notas_fct_ord
```

F√≠jate que ahora tenemos una [**jerarqu√≠a**]{.hl-yellow} y aunque sea cualitativa podemos buscar [**elementos \<= o \>= que otros**]{.hl-yellow}

```{r}
notas_fct_ord[notas_fct_ord <= "notable"]
```

---

## Par√©ntesis: factores

La idea de los factores


```{r}
library(forcats)
notas_sin_notable <- notas_fct_ord[notas_fct_ord != "notable"]
notas_sin_notable

fct_count(notas_sin_notable)
```

---

## Tablas de frecuencias

Volviendo a nuestro ejemplo de accidentes, ¬øc√≥mo convertir `estado_meteorol√≥gico` en una variable cualitativa ordinal? Debemos usar el concepto de factor pero, para no aislar la variable de su tabla (`tidyverse` mood), lo introduciremos en un `mutate()`, agrupando primero los distintos tipos de ausente

. . .

```{r}
accidentes_tb <-
  accidentes_tb |> 
  mutate(estado_meteorol√≥gico = 
           if_else(estado_meteorol√≥gico %in% c("NULL", "Se desconoce"),
                   "Ausente", estado_meteorol√≥gico),
         estado_meteorol√≥gico =
           factor(estado_meteorol√≥gico,
                  labels = c("Ausente", "Despejado", "Nublado", "Lluvia d√©bil",
                             "Lluvia intensa", "Nevando", "Granizando")))
accidentes_tb |> 
  count(estado_meteorol√≥gico)
```


---

## Tablas de frecuencias

F√≠jate que ahora al hacer `count()` ya no aparece la tabla de frecuencias ordenada por orden alfab√©tico sino [**ordenada por la jerarqu√≠a de orden**]{.hl-yellow} de la que hemos dotado a nuestra variable ordinal

```{r}
tabla_freq <-
  accidentes_tb |> 
  count(estado_meteorol√≥gico) |> 
  mutate("frec_rel" = n/sum(n))
tabla_freq
```

---

## Tablas de frecuencias

En los casos en los que la variable admita un orden (cuantitativas o cualitativas ordinales) podremos obtener **dos elementos m√°s de la tabla de frecuencias**, las [**frecuencias acumuladas**]{.hl-yellow}, que podemos sacar con `cumsum()`

-   **Frecuencia absoluta acumulada de x**: n¬∫ de observaciones menores o iguales que cada modalidad de x (solo apto para cuantitativas o cualitativas ordinales ya que necesitamos una estructura de orden).

-   **Frecuencia relativa acumulada de x**: proporci√≥n de valores menores o iguales que cada modalidad de x (solo apto para cuantitativas o cualitativas ordinales ya que necesitamos una estructura de orden).


```{r}
tabla_freq <- 
  tabla_freq |>
  mutate("frec_abs_acum" = cumsum(n),
         "frec_rel_acum" = cumsum(frec_rel))
tabla_freq

# o bien
cumsum(table(accidentes_tb$estado_meteorol√≥gico))
cumsum(prop.table(table(accidentes_tb$estado_meteorol√≥gico)))
```

---

## üíª Tu turno {#tu-turno-2-3}

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Para repasar lo aprendido vamos a poner todo en pr√°ctica con el dataset `SatisfaccionPacientes.csv`. [**¬øC√≥mo importarlo?**]{.hl-yellow}.

```{r}
#| code-fold: true
library(readr) # dentro de tidyverse
# en mi caso tengo el .csv en una carpeta datos dentro del proyecto
datos <-
  read_csv(file = "./datos/SatisfaccionPacientes.csv") |> 
  # la funci√≥n clean_names del paquete janitor 
  # nos normaliza nombres de variables
  janitor::clean_names()
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Aplica el c√≥digo que sea necesario para responder a estas preguntas. ¬øCu√°l es el tama√±o muestral? ¬øCu√°ntas variables tenemos? ¬øCu√°ntas modalidades tenemos en la variable `estado_civil` (y cuantas observaciones en cada una)?

```{r}
#| code-fold: true
#| eval: false
# Tama√±o muestral / n√∫mero de observaciones
n <- nrow(datos)

# N√∫mero de variables
p <- ncol(datos)

# ¬øQu√© modalidades tenemos?
datos |>  count(estado_civil)
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Determina el tipo de variable (cuantitativa vs. cualitativa).

```{r}
#| code-fold: true
#| eval: false
# Variables cuantitativas: tiempo, grado satisfacci√≥n, n√∫mero de visitas
# Variables cualitativas: g√©nero, estado civil, estado salud
glimpse(datos)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù  Obten tablas de frecuencias (absoluta y relativa) en el caso de las cualitativas NOMINALES. Con ella intenta responder a las preguntas: a) ¬øcu√°ntas mujeres hay? b) ¬øqu√© % de individuos est√°n casados?

```{r}
#| code-fold: true
#| eval: false
# no podemos calcular acumulados ya que genero es nominal
datos |>  count(genero) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))
# Hay 53 mujeres

datos |> count(estado_civil) |> 
  rename(frecuencia_abs = n) |> 
  mutate(frecuencia_rel = frecuencia_abs/sum(frecuencia_abs))
# Hay 26% personas casadas
```


### [**Ejercicio 5**]{.hl-yellow}

üìù Convierte de manera adecuada la variable `genero` y `estado_civil` a cualitativa nominal

```{r}
#| code-fold: true
datos <-
  datos |>
  mutate(estado_civil = factor(estado_civil),
         genero = factor(genero))
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Calcula la media, mediana, rango intercuart√≠lico y desviaci√≥n t√≠pica de edad y tiempo de espera.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad), mediana_edad = median(edad),
           IQR_edad = quantile(edad, probs = 0.75) - quantile(edad, probs = 0.25),
           # tiempo espera
           media_tiempo_espera = mean(tiempo_espera), sd_tiempo_espera = sd(tiempo_espera),
           mediana_tiempo_espera = median(tiempo_espera),
           IQR_tiempo_espera = quantile(tiempo_espera, probs = 0.75) - quantile(tiempo_espera, probs = 0.25))
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Repite el anterior ejercicio pero obteniendo las m√©tricas desagregadas por sexo.

```{r}
#| code-fold: true
resumen <-
  datos |>
  summarise(media_edad = mean(edad), sd_edad = sd(edad), mediana_edad = median(edad),
           IQR_edad = quantile(edad, probs = 0.75) - quantile(edad, probs = 0.25),
           # tiempo espera
           media_tiempo_espera = mean(tiempo_espera), sd_tiempo_espera = sd(tiempo_espera),
           mediana_tiempo_espera = median(tiempo_espera),
           IQR_tiempo_espera = quantile(tiempo_espera, probs = 0.75) - quantile(tiempo_espera, probs = 0.25),
          .by = genero)
```


:::

---


## üê£ Caso pr√°ctico III: brexit {#caso-practico-2-3}

![](https://media.tenor.com/dn2Mqp-ZPL4AAAAM/boris-boris-johnson.gif)

Vamos a analizar un caso real basado en los art√≠culos [¬´The Brexit Vote: A Divided Nation, a Divided Continent¬ª (S. B. Hobolt, 2016)](https://www.tandfonline.com/doi/full/10.1080/13501763.2016.1225785) y  [¬´Who Voted for Brexit? A Comprehensive District-Level Analysis¬ª (S. O. Becker et al., 2017)](https://academic.oup.com/economicpolicy/article/32/92/601/4459491). 

Los datos se extraer√°n del repositorio de Github de [Elena Llaudet](https://raw.githubusercontent.com/ellaudet/DSS/refs/heads/master/BES.csv).

&nbsp;

Intenta responder a las preguntas planteadas en el [**workbook**](https://javieralvarezliebana.quarto.pub/workbook-rtve/#caso-pr%C3%A1ctico-iii-brexit)

---
